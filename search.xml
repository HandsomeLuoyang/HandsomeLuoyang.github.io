<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql数据库基操,都坐下!</title>
    <url>/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%93%8D-%E9%83%BD%E5%9D%90%E4%B8%8B.html</url>
    <content><![CDATA[<h2 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h2><h4 id="链接数据库"><a href="#链接数据库" class="headerlink" title="链接数据库"></a>链接数据库</h4><pre><code>mysql -uroot -p
mysql -uroot -p[password]</code></pre><h4 id="退出数据库"><a href="#退出数据库" class="headerlink" title="退出数据库"></a>退出数据库</h4><pre><code>exit/quit/ctrl+d</code></pre><h4 id="sql语句最后需要有分号-结尾"><a href="#sql语句最后需要有分号-结尾" class="headerlink" title="sql语句最后需要有分号;结尾"></a>sql语句最后需要有分号;结尾</h4><h4 id="显示数据库版本"><a href="#显示数据库版本" class="headerlink" title="显示数据库版本"></a>显示数据库版本</h4><pre><code>select version();</code></pre><h4 id="显示时间"><a href="#显示时间" class="headerlink" title="显示时间"></a>显示时间</h4><pre><code>select now();</code></pre><h4 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h4><pre><code>show databases;</code></pre><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><pre><code>create database 数据库名 [charset = utf8];
create database python04;
create database python04new charset=utf8;</code></pre><h4 id="查看创建数据库的语句"><a href="#查看创建数据库的语句" class="headerlink" title="查看创建数据库的语句"></a>查看创建数据库的语句</h4><pre><code>show create database ....
show create database python04;</code></pre><h4 id="查看当前使用的数据库"><a href="#查看当前使用的数据库" class="headerlink" title="查看当前使用的数据库"></a>查看当前使用的数据库</h4><pre><code>select database();</code></pre><h4 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h4><pre><code>use 数据库的名字
use python04new;</code></pre><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><pre><code>drop database 数据库名;
drop database python04;</code></pre><h2 id="数据表的操作"><a href="#数据表的操作" class="headerlink" title="数据表的操作"></a>数据表的操作</h2><h4 id="查看当前数据库当中所有的表"><a href="#查看当前数据库当中所有的表" class="headerlink" title="查看当前数据库当中所有的表"></a>查看当前数据库当中所有的表</h4><pre><code>show tables;</code></pre><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><pre><code>auto_increment表示自动增长
not null 表示不能为空
primary key 表示主键
default 默认值
create table 数据表名字 (字段 类型 约束[, 字段 类型 约束]);
创建classes表(id, name)

create table xxxx(id int, name varchar(30));
create table yyyy(id int primary key not null auto_increment, name varchar(30));
create table zzzz(
    id int primary key not null auto_increment, 
    name varchar(30)
);</code></pre><h4 id="查看表的信息"><a href="#查看表的信息" class="headerlink" title="查看表的信息"></a>查看表的信息</h4><pre><code>desc 表的名字;
desc xxxx;</code></pre><h4 id="创建student表-id-name-age-high-gender-cls-id"><a href="#创建student表-id-name-age-high-gender-cls-id" class="headerlink" title="创建student表(id, name, age, high, gender, cls_id)"></a>创建student表(id, name, age, high, gender, cls_id)</h4><pre><code>create table students(
    id int unsigned auto_increment primary key not null,
    name varchar(30),
    age tinyint unsigned default 0,
    high decimal(5,2), 
    gender enum(&quot;男&quot;, &quot;女&quot;, &quot;中性&quot;, &quot;保密&quot;) default &quot;保密&quot;,
    cls_id int unsigned
);

insert into students values(0, &quot;laowang&quot;, 18, 188.50, &quot;男&quot;, 0);
select * from students;</code></pre><h4 id="创建classes表-id-name"><a href="#创建classes表-id-name" class="headerlink" title="创建classes表(id, name)"></a>创建classes表(id, name)</h4><pre><code>create table classes(
    id int unsigned not null primary key auto_increment, 
    name varchar(30)
);</code></pre><h4 id="查看表的创建语句"><a href="#查看表的创建语句" class="headerlink" title="查看表的创建语句"></a>查看表的创建语句</h4><pre><code>show create table 表名字;
show create table students;</code></pre><h4 id="修改表-添加字段"><a href="#修改表-添加字段" class="headerlink" title="修改表-添加字段"></a>修改表-添加字段</h4><pre><code>alter table 表名 add 列名 类型及约束;
alter table students add birthday datetime;</code></pre><h4 id="修改表-修改字段-不重命名版"><a href="#修改表-修改字段-不重命名版" class="headerlink" title="修改表-修改字段:不重命名版"></a>修改表-修改字段:不重命名版</h4><pre><code>alter table 表名 modify 列名 类型及约束
alter table students modify birthday date;</code></pre><h4 id="修改表-修改字段-重命名版"><a href="#修改表-修改字段-重命名版" class="headerlink" title="修改表-修改字段:重命名版"></a>修改表-修改字段:重命名版</h4><pre><code>alter table 表名 change 原列名 新列名 类型及约束;
alter table students change birthday birth date default &quot;2000-01-01&quot;;</code></pre><h4 id="修改表-删除字段"><a href="#修改表-删除字段" class="headerlink" title="修改表-删除字段"></a>修改表-删除字段</h4><pre><code>alter table 表名 drop 列名;
alter table students drop high;</code></pre><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><pre><code>drop database 数据库;
drop table 数据表;
drop table xxxx;</code></pre><h2 id="增删改查-curd"><a href="#增删改查-curd" class="headerlink" title="增删改查(curd)"></a>增删改查(curd)</h2><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><pre><code>全列插入
insert [into] 表名 values(...)
主键字段 可以用 0 null default 来占位

向classes表中插入一个班级
insert into classes values(0, &quot;菜鸟班&quot;);


+--------+-------------------------------------+------+-----+------------+----------------+
| Field  | Type                                | Null | Key | Default    | Extra          |
+--------+-------------------------------------+------+-----+------------+----------------+
| id     | int unsigned                        | NO   | PRI | NULL       | auto_increment |
| name   | varchar(30)                         | YES  |     | NULL       |                |
| age    | tinyint unsigned                    | YES  |     | 0          |                |
| gender | enum(&apos;男&apos;,&apos;女&apos;,&apos;中性&apos;,&apos;保密&apos;)        | YES  |     | 保密       |                |
| cls_id | int unsigned                        | YES  |     | NULL       |                |
| birth  | date                                | YES  |     | 2000-01-01 |                |
+--------+-------------------------------------+------+-----+------------+--------------

向students插入一个学生信息
insert into students values(0, &quot;小李飞刀&quot;, 20, &quot;女&quot;, 1, &quot;1990-01-01&quot;);
insert into students values(null, &quot;小李飞刀&quot;, 20, &quot;女&quot;, 1, &quot;1990-01-01&quot;);
insert into students values(default, &quot;小李飞刀&quot;, 20, &quot;女&quot;, 1, &quot;1990-01-01&quot;);

失败: insert into students values(default, &quot;小李飞刀&quot;, 20, &quot;第4性别&quot;, 1, &quot;1990-01-01&quot;);

枚举中的下标从1 开始 1---&quot;男&quot; 2---&quot;女&quot; 3---&quot;保密&quot;
insert into students values(default, &quot;小李飞刀&quot;, 20, 1, 1, &quot;1990-01-01&quot;);

部分插入
insert into 表名(列1,...) values(值1,...);
insert into students(name, gender) values(&quot;小乔&quot;, &quot;女&quot;);

多行插入
insert into students(name, gender) values(&quot;大乔&quot;, &quot;女&quot;), (&quot;貂蝉&quot;, &quot;女&quot;);
insert into students values(default, &quot;西施&quot;, 20, &quot;女&quot;, 1, &quot;1990-01-01&quot;), (default, &quot;王昭君&quot;, 20, &quot;女&quot;, 1, &quot;1990-01-01&quot;);</code></pre><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><pre><code>update 表名 set 列1=值1, 列2=值2... where 条件;
update students set gender=1; 全部都改
update students set gender=1 where name=&quot;小李飞刀&quot;; 只要name是小李飞刀的全部修改
update students set gender=1 where id=3; 只要id为3的就修改
update students set age=22, gender=1 where id=4; 只要id为4的，同时修改两处</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre><code>物理删除
delete from 表名 where 条件;
delete from students; 整个数据表中所有数据全部删除
delete from students where name=&quot;小李飞刀&quot;;

逻辑删除
用一个字段表示，这条信息已经不能再使用了
给students表添加一个is_delete字段 bit类型
alter table students add is_delete bit default 0;</code></pre><h4 id="查询基本使用"><a href="#查询基本使用" class="headerlink" title="查询基本使用"></a>查询基本使用</h4><pre><code>查询所有列
select * from 表名;
select * from students;

定条件查询
select * from students where name=&quot;小李飞刀&quot;; 查询name为小李飞刀的所有信息
select * from students where id&gt;3; 查询id&gt;3的信息

查询指定列
select name, gender from students;


可以用as为列或表指定别名
select 字段(as 别名) , 字段(as 别名) from 数据表 where...;
select name as 姓名, gender as 性别 from students;

字段的顺序
select id as 序号, gender as 性别, name as 姓名 from students;</code></pre><h2 id="数据的准备"><a href="#数据的准备" class="headerlink" title="数据的准备"></a>数据的准备</h2><h4 id="创建一个数据库"><a href="#创建一个数据库" class="headerlink" title="创建一个数据库"></a>创建一个数据库</h4><pre><code>create database python_test charset=utf8;</code></pre><h4 id="使用一个数据库"><a href="#使用一个数据库" class="headerlink" title="使用一个数据库"></a>使用一个数据库</h4><pre><code>use python_test;</code></pre><h4 id="显示当前使用的数据库"><a href="#显示当前使用的数据库" class="headerlink" title="显示当前使用的数据库"></a>显示当前使用的数据库</h4><pre><code>select database();</code></pre><h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><pre><code>students表
create table students(
    id int unsigned primary key not null auto_increment,
    name varchar(20) default &quot;&quot;,
    age tinyint unsigned default 0,
    height decimal(5,2),
    gender enum(&quot;男&quot;, &quot;女&quot;, &quot;保密&quot;) default &quot;保密&quot;,
    cls_id int unsigned default 0,
    is_delete bit default 0 
);

classes表
create table classes(
    id int unsigned primary key not null auto_increment,
    name varchar(20) not null
);</code></pre><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><pre><code>insert into students values
(0, &apos;小明&apos;,   18,180.00,2,1,0),
(0, &apos;小月月&apos;, 18,180.00,2,2,1),
(0, &apos;彭于晏&apos;, 29,185.00,1,1,0),
(0, &apos;刘德华&apos;, 59,175.00,1,2,1),
(0, &apos;黄蓉&apos;,   38,160.00,2,1,0),
(0, &apos;凤姐&apos; ,  28,150.00,4,2,1),
(0, &apos;王祖贤&apos;, 18,172.00,2,1,1),
(0, &apos;周杰伦&apos;, 36,  NULL,1,1,0),
(0, &apos;程坤&apos;,   27,181.00,1,2,0),
(0, &apos;刘亦菲&apos;, 25,166.00,2,2,0),
(0, &apos;金星&apos;,   33,162.00,3,3,1),
(0, &apos;静香&apos;,   12,180.00,2,4,0),
(0, &apos;郭靖&apos;,   12,170.00,1,4,0),
(0, &apos;周杰&apos;,   34,176.00,2,5,0);

insert into classes values
(0, &quot;python_01期&quot;),
(0, &quot;python_02期&quot;),
(0, &quot;python_04期&quot;);</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h4 id="查询所有字段"><a href="#查询所有字段" class="headerlink" title="查询所有字段"></a>查询所有字段</h4><pre><code>select * from students;
select * from classes;</code></pre><h4 id="查询指定字段"><a href="#查询指定字段" class="headerlink" title="查询指定字段"></a>查询指定字段</h4><pre><code>select 列1, 列2 from 表名;
select name, age from students;</code></pre><h4 id="使用as给字段起别名"><a href="#使用as给字段起别名" class="headerlink" title="使用as给字段起别名"></a>使用as给字段起别名</h4><pre><code>select 字段 as 名字... from 表名;
select name as 姓名, age as 年龄 from students;

select 表名.字段 .... from 表名;
select students.name , students.age from students;</code></pre><h4 id="可以通过as给表起别名"><a href="#可以通过as给表起别名" class="headerlink" title="可以通过as给表起别名"></a>可以通过as给表起别名</h4><pre><code>select 别名.字段 .... from 表名 as 别名;
select s.name , s.age from students as s;</code></pre><h4 id="消除重复行"><a href="#消除重复行" class="headerlink" title="消除重复行"></a>消除重复行</h4><pre><code>distinct 字段
select distinct gender from students;</code></pre><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><pre><code>select ... from 表名 where ....;

&gt;
查询大于18岁的信息
select * from students where age&gt;18;
select id, name, gender from students where age&gt;18;

&lt;
查询小于18岁的信息
select * from students where age&lt;18;

&gt;=
&lt;=
查询小于或者等于18岁的信息
select * from students where age&lt;=18;

=
查询年龄为18岁的所有学生的名字
select * from students where age=18;</code></pre><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><pre><code>and
18 到 28之间的所有学生信息
select * from students where age&gt;18 and age&lt;28;

18岁以上的女性
select * from students where age&gt;18 and gender=&quot;女&quot;;

or
18岁以上或身高超过180以上(包含)
select * from students where age&gt;18 or height &gt;= 180;

not 
不在18以上的女性 这个范围内的信息
select * from students where gender=2 and not age &gt; 18;
加括号可以改变优先级
select * from students where not (age &gt; 18 and gender=2);

年龄不是小于或者等于18 并且是女性
select * from students where (not age&lt;=18) and gender=2;</code></pre><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><pre><code>like
% 替换零个，一个或多个
_ 替换一个
查询姓名中 以&quot;小&quot; 开始的名字
select name from students where name like &quot;小%&quot;;

查询名字中 有&quot;小&quot; 的所有名字
select name from students where name like &quot;%小%&quot;;

查询有2个字的名字
select name from students where name like &quot;__&quot;;

查询有3个字的名字
select name from students where name like &quot;___&quot;;

查询至少两个字的名字
select name from students where name like &quot;__%&quot;;


rlike(查询正则表达式)
查询以 周 开头的名字
select name from students where name rlike &quot;^周.*&quot;;

查询以 周 开头，以 伦 结尾的名字
select name from students where name rlike &quot;^周.*伦$&quot;;</code></pre><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><pre><code>in (1, 3, 8) 表示在一个非连续的范围内
查询年龄为 18， 34 的姓名
select name, age from students where age = 18 or age = 34;
select name, age from students where age = 18 or age = 34 or age=12;
select name, age from students where age in (12, 18, 34);

not in 不在非连续的范围之内
年龄不是 18， 34岁之间的信息
select name, age from students where age not in (18, 34);

bteween ... and ... 表示在一个连续的范围之内 (左闭右闭)
查询 年龄在18到34之间的信息
select name, age from students where age between 18 and 34;

not between ... and ... 表示不在一个连续的范围之内
查询 年龄不在18到34岁之间的信息
select * from students where age not between 18 and 34; (记这种用法)

错误！！---&gt; **select * from students where age not (between 18 and 34); 因为not between是一个整体**

正确的用法是---&gt; **select * from students where not age between 18 and 34;**

判断空
判空 is null
查询身高为空的信息
select * from students where height is null;
select * from students where height is nuLL;
select * from students where height is NULL;

判非空
is not null;
select * from students where height is not null;</code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h4 id="order-by-字段"><a href="#order-by-字段" class="headerlink" title="order by 字段"></a>order by 字段</h4><pre><code>asc从小到大排列，即升序(默认)
desc 从大到小排列，即降序

查询年龄在18 到 34岁之间的男性，按照年龄从小到大排序
select * from students where (age between 18 and 34) and gender=1 order by age；
select * from students where (age between 18 and 34) and gender=1 order by age asc;

查询年龄在18 到 34岁之间的女性，按照身高从高到矮排序
select * from students where (age between 18 and 34) and gender=2 order by height desc;</code></pre><h4 id="order-by-多个字段"><a href="#order-by-多个字段" class="headerlink" title="order by 多个字段"></a>order by 多个字段</h4><pre><code>若第一个字段相同，按第二个字段，若第二个也相同，按第三个，以此类推
查询年龄在18到34岁之间的女性，身高从高到低排序，若身高相同，年龄从小到大
select * from students where (age between 18 and 34) and gender=2 order by height desc, age asc;

查询年龄在18到34岁之间的女性，身高从高到低排序，若身高相同，年龄从小到大，年龄相同id从大到小排
select * from students where (age between 18 and 34) and gender=2 order by height desc, age asc, id desc;

按照年龄从小到大，身高从高到矮排序
select * from students order by age asc, height desc;</code></pre><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><h4 id="总数"><a href="#总数" class="headerlink" title="总数"></a>总数</h4><pre><code>count
查询男性有多少人，女性有多少人
select * from students where gender=1;
select count(*) from students where gender=1;
select count(*) as 男性人数 from students where gender=1;

select count(*) as 女性人数 from students where gender=2;</code></pre><h4 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h4><pre><code>max
查询最大的年龄
select max(age) as 最大年龄 from students;

查询女性的最高身高
select max(height) as 女性最高身高 from students where gender=2;</code></pre><h4 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h4><pre><code>min</code></pre><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><pre><code>sum
计算所有人的年龄总和
select sum(age) as 年龄总和 from students;</code></pre><h4 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h4><pre><code>avg
计算平均年龄
select avg(age) as 年龄平均 from students;

计算平均年龄sum(age)/sum(*)
select sum(age)/sum(*) from students;</code></pre><h4 id="四舍五入-round-123-1-1-保留一位小数"><a href="#四舍五入-round-123-1-1-保留一位小数" class="headerlink" title="四舍五入 round(123.1, 1)保留一位小数"></a>四舍五入 round(123.1, 1)保留一位小数</h4><pre><code>计算所有人的平均年龄，保留2位小数
select round(sum(age)/sum(*), 2) from students;

计算男性的平均身高，保留两位小数
select round(avg(height),2) from students where gender=1;
失败---&gt;select name, round(avg(height),2) from students where gender=1;</code></pre><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><h4 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h4><pre><code>按照性别分组，查询所有的性别
失败---&gt;select name from students group by gender;
失败---&gt;select * from students group by gender;
select gender from students group by gender;

计算每种性别当中的人数
select gender, count(*) from students group by gender;

计算男性的人数
select gender, count(*) from students where gender=1 group by gender;</code></pre><h4 id="group-concat-…"><a href="#group-concat-…" class="headerlink" title="group_concat(…)"></a>group_concat(…)</h4><pre><code>查询同种性别中的姓名
select gender, group_concat(name) from students where gender=1 group by gender;
select gender, group_concat(name,age,id) from students where gender=1 group by gender;
select gender, group_concat(name,&quot; &quot;,age,&quot; &quot;,id) from students where gender=1 group by gender;</code></pre><h4 id="having-对分组进行条件判断"><a href="#having-对分组进行条件判断" class="headerlink" title="having (对分组进行条件判断)"></a>having (对分组进行条件判断)</h4><pre><code>查询平均年龄超过30岁的性别，以及姓名 having avg(age) &gt; 30
select gender, group_concat(name), avg(age) from students group by gender having avg(age) &gt; 30;

查询所有性别中的人数多于2个的信息
select gender, group_concat(name) from students group by gender having count(*)&gt;2;</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h4 id="limit-start-count-limit放在最后"><a href="#limit-start-count-limit放在最后" class="headerlink" title="limit start, count; (limit放在最后)"></a>limit start, count; (limit放在最后)</h4><pre><code>限制查询出来的数据个数
select * from students limit 2;

查询5个数据
select * from students limit 0, 5;

查询id 6-10(包含) 的分页
select * from students limit 5, 5;

每页显示两个，第1个页面
select * from students limit 0, 2;

每页显示两个，第2个页面
select * from students limit 2, 2;

每页显示两个，第3个页面
select * from students limit 4, 2;

每页显示两个，第4个页面
select * from students limit 6, 2; ---&gt;limit (第N页-1)*每页的个数，每页的个数

每页显示两个，显示第6页的信息， 按照年龄从小到大排序
失败---&gt;select * from students limit 2*(6-1), 2;
失败---&gt;select * from students limit 10, 2 order by age;
select * from students order by age limit 10, 2;</code></pre><h2 id="连接查询-mysql支持内连接和外连接，其中外连接分为左连接和右连接"><a href="#连接查询-mysql支持内连接和外连接，其中外连接分为左连接和右连接" class="headerlink" title="连接查询(mysql支持内连接和外连接，其中外连接分为左连接和右连接)"></a>连接查询(mysql支持内连接和外连接，其中外连接分为左连接和右连接)</h2><h4 id="inner-join-…-on"><a href="#inner-join-…-on" class="headerlink" title="inner join … on"></a>inner join … on</h4><pre><code>select ... from 表A inner join 表B;
select * from students inner join classes;

查询 有能够对应班级的学生以及班级信息
select * from students inner join classes on students.cls_id=classes.id;

按要求显示姓名，班级
select students.*, classes.name from students inner join classes on students.cls_id=classes.id;
select students.name, classes.name from students inner join classes on students.cls_id=classes.id;

给数据表起名字
select s.name, c.name from students as s inner join classes as c on s.cls_id=c.id;

查询 有能够对应班级的学生以及班级信息， 显示学生的所有信息， 只显示班级名称
select s.*, c.name from students as s inner join classes as c on s.cls_id=c.id;

在以上查询中，将班级名字放在第一列
select c.name, s.* from students as s inner join classes as c on s.cls_id=c.id;

查询 有能够对应班级的学生以及班级信息,按照班级进行排序
select c.name, s.* from students as s inner join classes as c on s.cls_id=c.id order by s.cls_id;

当同一个班级的时候，按照学生的id进行从小到大排序
select c.name, s.* from students as s inner join classes as c on s.cls_id=c.id order by s.cls_id, s.id;</code></pre><h4 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h4><pre><code>查询每位学生对应的班级信息
select * from students as s left join classes as c on s.cls_id=c.id;

查询没有对应班级信息的学生
select ... from xxx as s left join xxx as c on ... where ...;
select ... from xxx as s left join xxx as c on ... having ...;
select * from students as s left join classes as c on s.cls_id=c.id having c.id is null;(多个表的集使用having)
select * from students as s left join classes as c on s.cls_id=c.id where c.id is null;(一般原表使用where)</code></pre><h3 id="right-join"><a href="#right-join" class="headerlink" title="right join"></a>right join</h3><pre><code>将数据表名字互换位置，用left join完成</code></pre><h2 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h2><pre><code>通俗理解：一张表里面的某两个或者几个字段之间有关系，简称自关联(我关联我自己)

创建表
create table areas(
    aid int primary key not null,
    atitle varchar(20) default null,
    pid int default null
);

所需数据下载
https://pan.baidu.com/s/1Rk5-Xm5a4Xtckc3RmotYnA 提取码: yn78

在mysql内使用命令 source xxx.sql(需要在文件当前路径)即可执行文件内所有命令添加数据

查询出山东省有哪些市
select * from areas as province inner join areas as city on province.aid=city.pid having province.atitle=&quot;山东省&quot;;
select province.atitle, city.atitle from areas as province inner join areas as city on province.aid=city.pid having province.atitle=&quot;山东省&quot;;</code></pre><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><pre><code>子查询通俗来讲，就是一个select里面还包含有另一个子查询的信息，相当于函数的结果作为另一个函数的参数一样
标量子查询
查询出高于平均身高的信息
select * from students where height&gt;(select avg(height) from students);

查询最高的男生信息
select * from students where height = (select max(height) from students);

列级子查询
查询学生的班级号能对应的学生信息
select * from students where cls_id in (select id from classes);</code></pre>]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章让你拥有用不完的ip代理</title>
    <url>/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%A9%E4%BD%A0%E6%8B%A5%E6%9C%89%E7%94%A8%E4%B8%8D%E5%AE%8C%E7%9A%84ip%E4%BB%A3%E7%90%86.html</url>
    <content><![CDATA[<h4 id="本文包含代码所需的python外置库："><a href="#本文包含代码所需的python外置库：" class="headerlink" title="本文包含代码所需的python外置库："></a>本文包含代码所需的python外置库：</h4><ul><li><strong>requests</strong></li><li><strong>BeautifulSoup4</strong></li></ul><p>本文尤其适合对python爬虫有一定了解的人群，但是如果你是小白，也能从文章中获取一些互联网的知识</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着<strong>大数据时代来临</strong>，数据对于我们每个人来说都越来越重要，而互联网又是最重要、最广泛的数据获取来源。</p><p>在这个时代下，我们每个人都应该掌握一定的从互联网获取信息的能力。而<strong>python爬虫，就是我们从互联网获取信息的利器！</strong></p><p>当我们运用python爬虫从互联网上获取信息时，经常的会遇到<strong>被封IP</strong>的尴尬情况。</p><p>这是由于我们的爬虫占据了网站太多的服务器资源而又对它几乎没有任何益处，所以人家当然不允许你这么做。<br>所以我们需要<strong>使用代理</strong>来避免这种情况。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>网上有一些专门提供代理IP的网站，这里展现了两个，如果需要更多可以自行搜索查找。</p><p>1.<a href="https://www.xicidaili.com/" target="_blank" rel="noopener">西刺免费代理</a><br>免费IP非常多，这个网站也在很早就有了，但是有一个缺点，我爬取这个网站上的代理的时候爬不了几页就被封了！即使我每爬一页都设置了3秒钟的间隔。难道我还要用代理来爬取代理？于是我又找其他的代理网站。</p><p>2.<a href="http://www.xiladaili.com/" target="_blank" rel="noopener">西拉ip代理官网</a><br>本篇文章是使用这个网站爬取的IP，网站界面很好看，IP也很多，并且还提供了API每天五百个免费的量，重要的是封IP没那么严，爬取的时候可以放心爬（但是最好不要对它的服务器造成太大负荷，我是每一页间隔两秒钟）</p><p>先讲思路，代码放在下面：<br>1.请求网页的内容<br>2.使用BeautufulSoup4分析网页内容，提炼出需要的内容<br>3.程序可自主选择爬取http还是https的代理，高匿名还是透明代理(推荐高匿名)，爬取多少页<br>4.多线程对爬取下来的ip进行可用性检测（毕竟是免费的代理，很多都不能用的，需要自己进行检测)<br>5.写入文件（这部分可以改动）<br></p><p>##思路代码分析</p><ul><li><p>请求网页内容使用requests库的get方法就可以，并且在在get函数中传入proxies参数，参数是一个字典，类似下面这样</p><blockquote><p>通过 <strong>requests.get(url=url, headers=header,proxies={“http”:”<a href="http://xx.xx.xx.xx&quot;}" target="_blank" rel="noopener">http://xx.xx.xx.xx&quot;}</a>, timeout=5)</strong> 使用http协议的ip代理<br>或者<br>通过<strong>requests.get(url=url, headers=header,proxies={“https”:”<a href="https://xx.xx.xx.xx&quot;}" target="_blank" rel="noopener">https://xx.xx.xx.xx&quot;}</a>, timeout=5)</strong>使用https协议的ip代理</p></blockquote></li><li><p>西拉代理官网的元素很好分析，使用bs4几行就分析好了</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/20361402-930afa6fc04fe323.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="西拉元素分析"><br>我们需要的是上面截图中三个箭头的元素，因为本程序提供http和https的选择功能，还有匿名度的选择功能。<br>如果有需要其它选择选项比如代理位置或者响应速度什么的，可以自行修改，或者可以联系我。</p><ul><li><p>几个选项使用if判断语句判断一下分析出来的元素就可实现</p></li><li><p>ip可用性检测的方法是使用这个代理访问网站，若是访问成功则说明https代理有效，而http代理步骤稍多一步。http代理检测，是访问一个ip网站，这个网站会分析访问过来的ip并显示在页面上，我们获取这个元素然后和我们的代理进行比对来判断是否有效。多线程是由于若是ip不可用则至少花费5秒钟时间等待，这样显得效率十分低下，所以开多线程（鉴于GIL锁的存在，此处的多线程与python的协程差不多，有不懂的可以私信我）</p></li><li><p>写入文件这一部分很简单，但是可以作改动，因为从网上爬取下来的ip可能随时会失效，所以使用文件保存是不好的，最好是随时爬取，有效就直接用。可以考虑改造一下函数变成一个列表生成器，每次yield一个列表出去，列表里面放置了有效的ip。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">IP_MODE &#x3D; 1  # 1. http   2.https</span><br><span class="line">NI_MING_MODE &#x3D; 1  # 1.高匿   2.透明</span><br><span class="line">PAGE &#x3D; 50  # 默认爬取50页</span><br><span class="line"></span><br><span class="line">url &#x3D; &quot;&quot;</span><br><span class="line">if IP_MODE &#x3D;&#x3D; 1:</span><br><span class="line">    url &#x3D; &quot;http:&#x2F;&#x2F;www.xiladaili.com&#x2F;http&#x2F;&#123;&#125;&#x2F;&quot;</span><br><span class="line">elif IP_MODE &#x3D;&#x3D; 2:</span><br><span class="line">    url &#x3D; &quot;http:&#x2F;&#x2F;www.xiladaili.com&#x2F;https&#x2F;&#123;&#125;&#x2F;&quot;</span><br><span class="line">else:</span><br><span class="line">    # 输入其它数字默认为http</span><br><span class="line">    url &#x3D; &quot;http:&#x2F;&#x2F;www.xiladaili.com&#x2F;http&#x2F;&#123;&#125;&#x2F;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">header &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.117 Safari&#x2F;537.36&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_http(host):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    检测http代理IP是否有效并将有效IP写入文件</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    ip &#x3D; &#123;&#125;</span><br><span class="line">    ip[&quot;http&quot;] &#x3D; &quot;http:&#x2F;&#x2F;&quot; + host</span><br><span class="line">    # 通过访问下面这个ip检测网站来判断</span><br><span class="line">    url &#x3D; &quot;http:&#x2F;&#x2F;ip.tool.chinaz.com&#x2F;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # http无效的情况大致有两种 1.无法访问这个网页，那么这个代理不可用 2.能访问网页但是没有达到代理效果，即仍然使用的自己的ip访问网页</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        html &#x3D; requests.get(url&#x3D;url, headers&#x3D;header,</span><br><span class="line">                            proxies&#x3D;ip, timeout&#x3D;5).text</span><br><span class="line">    except:</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        soup &#x3D; BeautifulSoup(html, &quot;lxml&quot;)</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            real_ip &#x3D; soup.select_one(&quot;.fz24&quot;).text</span><br><span class="line">        except:</span><br><span class="line">            return</span><br><span class="line">        if real_ip &#x3D;&#x3D; host.split(&quot;:&quot;)[0]:</span><br><span class="line">            print(&quot;有效IP：&quot; + host)</span><br><span class="line">            with open(&quot;xila_http_list.txt&quot;, &quot;a&quot;) as af:</span><br><span class="line">                af.write(host + &quot; &quot;)</span><br><span class="line">        else:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_https(host):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    检测https代理是否有效，并将有效IP写入文件</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    ip &#x3D; &#123;&#125;</span><br><span class="line">    ip[&quot;https&quot;] &#x3D; &quot;https:&#x2F;&#x2F;&quot; + host</span><br><span class="line"></span><br><span class="line">    url &#x3D; &quot;https:&#x2F;&#x2F;blog.csdn.net&#x2F;luoyangIT&quot;</span><br><span class="line"></span><br><span class="line">    # https检测只能通过检查是否能访问https协议的网页来判断，若有其它方法则继续增加</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        html &#x3D; requests.get(url&#x3D;url, headers&#x3D;header,</span><br><span class="line">                            proxies&#x3D;ip, timeout&#x3D;5).text</span><br><span class="line">    except:</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;有效IP：&quot; + host)</span><br><span class="line">        with open(&quot;xila_https_list.txt&quot;, &quot;a&quot;) as af:</span><br><span class="line">            af.write(host + &quot; &quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    主函数，入口</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    for i in range(1, PAGE):</span><br><span class="line">        # 延时，避免对服务器造成太大负荷，同时在延时时间内检测代理可用情况</span><br><span class="line">        time.sleep(3)</span><br><span class="line">        # 请求页面text</span><br><span class="line">        html &#x3D; requests.get(url&#x3D;url.format(i), headers&#x3D;header).text</span><br><span class="line">        soup &#x3D; BeautifulSoup(html, &quot;lxml&quot;)</span><br><span class="line">        # 分析元素</span><br><span class="line">        tr_list &#x3D; soup.select_one(&quot;.fl-table&quot;).select_one(&quot;tbody&quot;).select(&quot;tr&quot;)</span><br><span class="line">        # 获取元素</span><br><span class="line">        for td_list in tr_list:</span><br><span class="line">            # 高匿</span><br><span class="line">            if NI_MING_MODE &#x3D;&#x3D; 1 and &quot;高匿&quot; in td_list.select(&quot;td&quot;)[2].text:</span><br><span class="line"></span><br><span class="line">                # http</span><br><span class="line">                if IP_MODE &#x3D;&#x3D; 1:</span><br><span class="line">                    t &#x3D; threading.Thread(target&#x3D;test_http, args&#x3D;(</span><br><span class="line">                        td_list.select(&quot;td&quot;)[0].text,))</span><br><span class="line">                    t.start()</span><br><span class="line"></span><br><span class="line">                # https</span><br><span class="line">                elif IP_MODE &#x3D;&#x3D; 2 and test_https(td_list.select(&quot;td&quot;)[0].text):</span><br><span class="line">                    t &#x3D; threading.Thread(target&#x3D;test_https, args&#x3D;(</span><br><span class="line">                        td_list.select(&quot;td&quot;)[0].text,))</span><br><span class="line">                    t.start()</span><br><span class="line"></span><br><span class="line">            # 透明</span><br><span class="line">            elif NI_MING_MODE &#x3D;&#x3D; 2 and &quot;透明&quot; in td_list.select(&quot;td&quot;)[2].text:</span><br><span class="line"></span><br><span class="line">                # http</span><br><span class="line">                if IP_MODE &#x3D;&#x3D; 1:</span><br><span class="line">                    t &#x3D; threading.Thread(target&#x3D;test_http, args&#x3D;(</span><br><span class="line">                        td_list.select(&quot;td&quot;)[0].text,))</span><br><span class="line">                    t.start()</span><br><span class="line"></span><br><span class="line">                # https</span><br><span class="line">                elif IP_MODE &#x3D;&#x3D; 2:</span><br><span class="line"></span><br><span class="line">                    t &#x3D; threading.Thread(target&#x3D;test_https, args&#x3D;(</span><br><span class="line">                        td_list.select(&quot;td&quot;)[0].text,))</span><br><span class="line">                    t.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>代码中我已附上大量注释，希望大家都能看懂，不懂得可以私信我交流。</p><p>我是落阳，谢谢你的到访！希望大家都平平安安健健康康！</p>]]></content>
      <tags>
        <tag>python</tag>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>udp聊天室的界面实现</title>
    <url>/udp%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%9A%84%E7%95%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<p>上一次我展现了udp聊天室的功能代码实现，这一次我已经实现了udp聊天室的界面啦，一起来看看吧！</p><a id="more"></a><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDM2MTQwMi1hYWI1N2U0MDU5ZmRmNjI4LnBuZw?x-oss-process=image/format,png" alt="udp聊天室.png"></p><p>这就是界面的样子，我是使用qt来设计的界面然后使用qsss美化的界面，背景使用了一个渐变色，上面是一个消息浏览框，下面是消息发送框，点击发送按钮即可发送。<br>右上方是一个小小的lineEdit框，代表要连接上的udp服务器的ip，端口默认是6666，输入完之后点击确认即会默认向服务器udp发送一条到来消息，表示有个客户端的到来。并且若是输入的ip无法连接或不存在，会有信息框提示。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDM2MTQwMi1kMjU3YWRkNTVmMTdmNjUxLnBuZw?x-oss-process=image/format,png" alt="错误信息.png"></p><p>就像这样</p><p>目前只对客户端写了界面噢，服务器端的那个udp并没有写界面，直接是在命令终端显示。</p><p>效果图如下<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDM2MTQwMi00ZDg0NWYyZGIyODhmOTk1LnBuZw?x-oss-process=image/format,png" alt="udp聊天室.png"></p><p>如果想要源码的话，可以到我的微信公众号后台发送【udp聊天室】获取源码</p>]]></content>
      <tags>
        <tag>python</tag>
        <tag>udp</tag>
        <tag>聊天室</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>挂载程序在我的第一台阿里云服务器上</title>
    <url>/%E6%8C%82%E8%BD%BD%E7%A8%8B%E5%BA%8F%E5%9C%A8%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8F%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A.html</url>
    <content><![CDATA[<p><strong>背景：</strong> 我一直想着要是有一台可以不用关机，性能强大，网速飞快的电脑属于我自己该多好，我可以用它来做好多的事情，程序可以二十四小时无死角的运行，正好我最近在追一部小说，不想自己老是去软件里面翻看它更新了没有，心里总念叨着。于是我就用python写了一个程序来检测，当小说有新章节的时候马上发邮件提醒我，这样我就可以第一时间看到新章节同时也不用时刻念叨着它了。<br>说干就干。<br>啪嗒啪嗒—-</p><a id="more"></a><p>忙活了一会，程序是写好了，调试也没问题，能用！<br>然后我开开心心把它在我的windows上跑起来<br>一分钟，两分钟<br>诶这不是个事啊，按小说作者的尿性，估计要一两天才更新一章，我这开着vscode一直运行我的程序，不爽啊，而且，我电脑是要关机的啊，每次开机都要重新挂起这个窗口？真心不爽<br>于是乎，我上网啪嗒啪嗒查了一会，发现可以在命令行中使用pythonw命令直接运行python程序而不显示窗口<br><img src="https://upload-images.jianshu.io/upload_images/20361402-ea9b04fe5f47c61d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>大概是这样<br>这样做的效果呢，就是我只要跑到命令行去输一遍这个命令就可以了，这个程序会在windows的后台跑，不用我用vscode一直运行它</p><hr><p>这样用了几天，那个尿性不改的作者还是个夜猫子！一两天不更新，偏偏在大晚上的更新，我电脑不用关机的嘛？<br>而且，每次开机都要重新输入一遍命令，还是不太爽，那万一以后我想挂载的程序越来越多怎么办？是不是要输那么多个命令？倒也不用，写个脚本就可以，脚本里面运行这些程序，然后每次开机就运行一下这个脚本。<br>可偏偏我是个强迫癌患者，同时也带有一点点完美主义。<br>于是我想，必须要有一台服务器啊<br>我的大数据开发老师倒是有一台服务器，但是那台服务器是供很多很多人用的，我的python程序里面有一些不能被大家看的东西，邮箱密钥什么的，而且老师这台服务器是任何人都可以获得root权限的，也就是说指不定谁就把服务器关机了或者把服务器搞坏了，到时候老师要用快照复原服务器。那我的程序怎么办！！！！！！<br>思来想去，最后把主意打到了阿里云服务器上，首先去申请了一个月的服务器试用。然后配置好服务器之后。（如果对配置阿里云服务器有什么问题的可以私信问我，但是我也是个小白，知道的很少）<br>然后用xshell连上服务器，用xftp来传输文件到服务器上。<br>于是乎！于是乎！我的程序就这样挂在了阿里云的服务器上，这回是真的二十四小时开机，同时信息基本不会泄露，也不用担心别个把服务器搞坏了。那个尿性十足的作者半夜更新我也能收到了!!!<br>顺带提一下，挂载程序肯定是挂在后台的，不然的话就只能运行一个了呀，这多不爽。<br>在linux系统上后台运行程序的方法是在命令后面加个&amp;，但是这样这个后台程序可能会被杀死掉，所以我们这样挂载。<br><img src="https://upload-images.jianshu.io/upload_images/20361402-98ab48fab18c2ada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>解释一下 nohup 是linux的命令，大致就是保持程序运行不掉线吧<br>然后python是运行python程序的命令<br>后面那个 &gt; xiaoshuo.log 意思是在我的程序里面，如果有异常，或者print标准输出之类的，都会被放到xiaoshuo.log这个文件里面去（毕竟是后台运行嘛，你不能指望它直接print在屏幕上）<br>然后 -u 那个参数代表取消python程序的缓冲，凡是有任何输出马上就放到xiaoshuo.log里面去，不然的话可能要等很久很久xiaoshuo.log才会有东西了。<br>最后那个 &amp; 就是代表后台运行啦！<br><img src="https://upload-images.jianshu.io/upload_images/20361402-7120ec62507715eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以使用ps或者jobs命令，看到程序确实是在后台运行啦！<br>very good！<br>bye! 谢谢你来看我哟！<br>祝大家元旦快乐，虽然过了一天了嘻<br>如果有其它可以挂在服务器上的程序的好点子，可以联系我我们共同探讨！</p>]]></content>
      <tags>
        <tag>linux</tag>
        <tag>python</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>udp聊天？使用udp+python实现多人聊天室</title>
    <url>/udp%E8%81%8A%E5%A4%A9%EF%BC%9F%E4%BD%BF%E7%94%A8udp-python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4.html</url>
    <content><![CDATA[<p>相信来到这个文章里面的朋友不会对udp陌生，话不多说直接开始。<br>由于udp没有建立连接，也没有实际上的客户端和服务器端。<br>但是我们需要让一个udp来充当服务器！实现消息广播从而达到聊天室的效果。<br>以下是充当服务器的udp代码↓↓↓</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># *^-^* coding:utf-8 *^-^*</span><br><span class="line"># Author:Luoyang</span><br><span class="line"># CreatTime:2019-12-19 19:47</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line">import datetime</span><br><span class="line">import threading</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def broadcast_msg(udp_sever, msg, addr, addr_list):</span><br><span class="line">    for each_addr in addr_list:</span><br><span class="line">        if each_addr !&#x3D; addr:</span><br><span class="line">            udp_sever.sendto(u&quot;&lt;from:&#123;0&#125; time:&#123;1&#125; &gt;: &#123;2&#125;&quot;.format(</span><br><span class="line">                addr[0], datetime.datetime.now().strftime(&quot;%Y.%m.%d-%H:%M:%S&quot;), msg).encode(&quot;utf-8&quot;), each_addr)</span><br><span class="line">        else:</span><br><span class="line">            udp_sever.sendto(&quot;u&lt;from:you time:&#123;0&#125; you&gt;: &#123;1&#125;&quot;.format(datetime.datetime.now().strftime(</span><br><span class="line">                &quot;%Y.%m.%d-%H:%M:%S&quot;), msg).encode(&quot;utf-8&quot;), addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 1.创建一个udp，绑定本机的ip和一个固定端口</span><br><span class="line">    udp_sever &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    udp_sever.bind((&quot;&quot;, 6666))</span><br><span class="line">    print(&quot;udp服务器正在运行中...&quot;)</span><br><span class="line">    # 2.死循环接收消息，当接受到之后，默认认为这个ip加入聊天室，将这个ip加入列表当中，并把它的消息广播给所有ip</span><br><span class="line">    # Creat a ip list.</span><br><span class="line">    addr_list &#x3D; []</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            msg, addr &#x3D; udp_sever.recvfrom(1024)</span><br><span class="line">            # print(msg.decode(&quot;utf8&quot;), addr)</span><br><span class="line">            try:</span><br><span class="line">                msg &#x3D; msg.decode(&quot;utf-8&quot;)</span><br><span class="line">            except:</span><br><span class="line">                msg &#x3D; msg.decode(&quot;gbk&quot;)</span><br><span class="line">            if msg &#x3D;&#x3D; &quot;quit()&quot;:</span><br><span class="line">                if addr in addr_list:</span><br><span class="line">                    addr_list.remove(addr)</span><br><span class="line">                    print(&quot;&#123;0&#125; 退出聊天室\n&quot;.format(addr))</span><br><span class="line">                    continue</span><br><span class="line">                else:</span><br><span class="line">                    continue</span><br><span class="line">            if addr not in addr_list:</span><br><span class="line">                addr_list.append(addr)</span><br><span class="line">                print(&quot;%s 加入聊天室\n&quot; % str(addr))</span><br><span class="line"></span><br><span class="line">            print(&quot;&lt;time:&#123;0&#125;&gt; ip:&#123;1&#125;&gt;: &#123;2&#125; \n&quot;.format(datetime.datetime.now().strftime(</span><br><span class="line">                &quot;%Y.%m.%d-%H:%M:%S&quot;), addr[0], msg))</span><br><span class="line">            t &#x3D; threading.Thread(target&#x3D;broadcast_msg, args&#x3D;(</span><br><span class="line">                udp_sever, msg, addr, addr_list))</span><br><span class="line">            t.start()</span><br><span class="line">        except Exception as ret:</span><br><span class="line">            print(ret)</span><br><span class="line">    udp_sever.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>如果是想在linux上运行的朋友按照管理在第一行加上</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!usr&#x2F;bin&#x2F;env python3</span><br></pre></td></tr></table></figure><p>实现原理很简单，当udp服务器收到某个地址给它发过来的消息的时候，将这个地址加入到列表中（方便广播），以后再收到其它地址发过来的消息的时候为这个列表中的每个地址发送同样的消息，并附上发送者的ip地址。<br>如果列表只增不减，最后效率会变低，会浪费很多时间和资源。<br>所以我们约定，当某个聊天室成员想退出聊天室的时候，发送一个quit()字符串过去，udp服务器就明白你要退出去了，就把你的ip地址从广播列表中移出去，这条消息并不会广播出去。（由于我这里没写界面，所以需要手动发送quit(), 如果写了界面的话，可以把发送这个消息放到界面的关闭按钮中，即一点关闭就会发送这条消息，那就很方便啦！）</p><p>udp服务器端实现的很简单。同样的，客户端也很简单</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># *^-^* coding:utf-8 *^-^*</span><br><span class="line"># Author:Luoyang</span><br><span class="line"># CreatTime:2019-12-19 19:47</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line">import threading</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def recv_msg(udp_client):</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            msg &#x3D; udp_client.recv(1024)</span><br><span class="line">            try:</span><br><span class="line">                msg &#x3D; msg.decode(&quot;utf-8&quot;)</span><br><span class="line">            except:</span><br><span class="line">                msg &#x3D; msg.decode(&quot;gbk&quot;)</span><br><span class="line">            finally:</span><br><span class="line">                print(&quot;\n&quot; + msg)</span><br><span class="line">        except Exception as ret:</span><br><span class="line">            print(ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 1.Creat a udp socket.</span><br><span class="line">    udp_client &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    # 2.Bind the socket to local ip and port, and send a message to udp_sever indicating I&#39;m coming!</span><br><span class="line">    host_name &#x3D; socket.gethostname()</span><br><span class="line">    # Get local ip.</span><br><span class="line">    local_addr &#x3D; socket.gethostbyname(host_name)</span><br><span class="line">    udp_client.bind((&quot;&quot;, 8080))</span><br><span class="line">    # Tell everyone and the sever that you are coming.</span><br><span class="line">    sever_addr &#x3D; (&quot;10.1.156.82&quot;, 6666)</span><br><span class="line">    udp_client.sendto(&quot;Hello everyone &#123;0&#125; is coming!&quot;.format(</span><br><span class="line">        local_addr).encode(&quot;utf-8&quot;), sever_addr)</span><br><span class="line">    # 4.Creat a thread to receive msg from others.</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;recv_msg, args&#x3D;(udp_client, ))</span><br><span class="line">    t.start()</span><br><span class="line">    # 5.Always ready to send message.12</span><br><span class="line">    while True:</span><br><span class="line">        msg &#x3D; input(&quot;请输入你要发送的消息：&quot;)</span><br><span class="line">        udp_client.sendto(msg.encode(&quot;utf-8&quot;), sever_addr)</span><br><span class="line">        if msg &#x3D;&#x3D; &quot;quit()&quot;:</span><br><span class="line">            break</span><br><span class="line">    udp_client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>linux用户同理在第一行加上文提到的代码。<br>udp客户端基本没什么实现的难度，就一个多线程同时实现收和发。<br>发消息对着服务器的地址发送，然后你的消息就会被所有正在聊天室内的客户端接收到。同时另外开一个线程保证在发消息的同时也能显示出其他客户端发送的消息，这样我们就实现了聊天室的功能啦！（由于这里同样没有写界面，所以同时收发消息就会显得有点格式乱，写了界面之后可以把收和发放到两个框框里面，就会很美观啦！）</p><p>另外这里标注一下，在我的代码中，udp客户端内部固定了某个服务器udp，也就是说，udp客户端一打开就连上了一个特定的服务器。这里需要改造一下，不然是用不了的。要么把服务端内部的特定地址改成你想当作服务器的那个ip的地址，要么可以使用输入的方式动态决定服务器地址，都可以~</p><p>虽然看着很简陋，但是要是界面写得好，代码再优化一下，完全可以达到qq群聊天的效果！！</p><p>如果代码有什么疑问想和我讨论的话欢迎关注联系我，我们一起讨论加油！</p>]]></content>
      <tags>
        <tag>python</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title>python多任务之——线程简述</title>
    <url>/python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B9%8B%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%BF%B0.html</url>
    <content><![CDATA[<h3 id="python多线程复习"><a href="#python多线程复习" class="headerlink" title="python多线程复习"></a>python多线程复习</h3><p>无论你使用什么语言，多线程一直都有着举足轻重的地位，只要线程开得多，任务还能凑几桌（头发还得不停脱），哈哈哈开个玩笑。那么何谓多线程？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def sing():</span><br><span class="line">    &quot;&quot;&quot;唱歌 5秒钟&quot;&quot;&quot;</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;------正在唱：妹妹你大胆滴往前走啊------&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dance():</span><br><span class="line">    &quot;&quot;&quot;跳舞 5秒钟&quot;&quot;&quot;</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;------正在跳舞------&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    sing()</span><br><span class="line">    dance()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>我们的程序默认只有一个主线程，主线程一条一条语句执行，于是上面这串代码的结果是这样的</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20191122232211924.gif" alt="单任务"></p><p>接下来我们简单的加上一个进程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def sing():</span><br><span class="line">    &quot;&quot;&quot;唱歌 5秒钟&quot;&quot;&quot;</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;------正在唱：妹妹你大胆滴往前走啊------&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dance():</span><br><span class="line">    &quot;&quot;&quot;跳舞 5秒钟&quot;&quot;&quot;</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&quot;------正在跳舞------&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    t1 &#x3D; threading.Thread(target&#x3D;sing)</span><br><span class="line">    t2 &#x3D; threading.Thread(target&#x3D;dance)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>立马鸟枪换炮<br><img src="https://img-blog.csdnimg.cn/20191122232447481.gif" alt="多进程"><br>以上就是实现了两个进程同时运行的效果</p><p>这里说一下原理：<br>我们平时写程序，算法和数据结构之类的，都没有用到多进程，<strong>程序默认就只有一个线程——主线程</strong>，这个主进程从起点向下一条一条执行语句，如果是c类语言就从main函数开始执行，一条一条的来。当我们加入多任务之后，主线程只要执行到产生多线程的语句就会创造出子线程来，在我这个程序中就是这里</p><blockquote><p>t1 = threading.Thread(target=sing)<br>t2 = threading.Thread(target=dance)<br>t1.start()<br>t2.start()</p></blockquote><p>当执行到第一句的话，马上就创建一个子线程跑到target， 即sing函数那里去待命，同理，主线程到了t2那里也会创建出一个子线程跑到dance函数那里去待命，当主线程一执行到start()函数的时候，早已蓄势待发的子线程马上开始它的任务。</p><p>注意！主线程会等待子线程，也就是说当子线程的任务还没执行完的时候，主线程是不能退出程序的，因为只要主线程一挂掉，子线程一个都不能活。</p><p>今天就先到这里。<br>谢谢你来看我！！你的关注对我非常重要！</p>]]></content>
      <tags>
        <tag>python</tag>
        <tag>多任务</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要学linux命令以及linux的文件与目录命令</title>
    <url>/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6linux%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8Alinux(ubuntu)%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<h3 id="今天补充学习了一下linux的文件与目录操作，来复习一下"><a href="#今天补充学习了一下linux的文件与目录操作，来复习一下" class="headerlink" title="今天补充学习了一下linux的文件与目录操作，来复习一下"></a>今天补充学习了一下linux的文件与目录操作，来复习一下</h3><hr><blockquote><p>明明linux发行版的图形操作界面做的已经完全足够我们日常使用了，为什么我们还是一定要学linux的命令？<br>那是由linux的主要功能决定的，目前来说linux操作系统主要应用于服务器与嵌入式设备当中。<br>嵌入式设备不用多说，大部分的嵌入式设备是不可能拥有像是我们电脑这样完善的界面和操作方式的。<br>那么对于服务器来说，服务器就是一台电脑，装载了linux系统，被放置在公司或者学校的机房中，像这样。</p></blockquote><a id="more"></a><blockquote><p><img src="https://img-blog.csdnimg.cn/20191116165355854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="机房"><br>为了电脑的散热和安全，机房里面温度十分低，并且机房里面噪音非常大。难道我们还能每个人搬个小板凳坐在机房里面，一群人围着柜子操作嘛？环境与效率都不允许我们这么做。<br>那么我们怎么做呢？记住一点，linux是基于Unix开发的，而Unix设计的初衷就是为了多个用户同时在一台电脑上工作，共享一台电脑的硬件，我们通常是远程来对服务器进行维护。<br>这里又扯远一点，远程维护，如果我们使用的是苹果系统，那么直接可以在终端连上服务器对它进行维护，如果是Windows上我们需要安装工具连上服务器对它进行操作。但是无论是哪种方式。<strong>都是没有界面的！！！只有一个黑框框，也就是终端命令框！</strong> 这也就是为什么我们要学命令的原因。</p></blockquote><p>下面我们开始讲一下基础命令</p><hr><h5 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h5><p>这里讲两个最最最常用重要的命令，ls和cd</p><blockquote><p>ls（选项）（参数）</p></blockquote><blockquote><p>选项：<br>-a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；<br>-C：多列显示输出结果。这是默认选项；<br>-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；<br>-i：显示文件索引节点号（inode）。一个索引节点代表一个文件；<br>-t：用文件和目录的更改时间排序；</p></blockquote><p>拿我自己的ubuntu举例子：<br><img src="https://img-blog.csdnimg.cn/20191116173023635.png" alt="默认情况下"><br>↑↑↑这是默认情况下，可以看到呈多行显示，并且只显示个文件名<br><img src="https://img-blog.csdnimg.cn/20191116173223373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="全部文件"><br>↑↑↑这个是加了选项 -a之后，我们发现以 . 开头的隐藏文件也显示出来了<br><img src="https://img-blog.csdnimg.cn/20191116173402596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="长格式显示"><br>↑↑↑ 这个就是长格式显示文件和目录，出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等。</p><p>剩下的选项请自己去尝试喔</p><p>有个小提示：我们可以多个选项一起使用，放在一个 - 后面，例如 ls -al</p><p>又有一个小提示：平时我们喜欢用 ls -al ，用的多了觉得它麻烦怎么办，这里有个 ll 操作，是它的别名， ls -al == ll 。相信我你会喜欢上它的。</p><blockquote><p>cd (选项) (参数)</p></blockquote><p>关于cd命令，一般情况下我们也是不需要使用选项的，直接带着参数跑</p><p>但是这里有些特殊的参数需要记忆一下</p><blockquote><p>cd 进入用户主目录；<br>cd ~ 进入用户主目录；<br>cd - 返回进入此目录之前所在的目录；<br>cd .. 返回上级目录（若当前目录为“/“，则执行完后还在“/“；”..”为上级目录的意思）；<br>cd ../.. 返回上两级目录；</p></blockquote><p>其中cd 和cd ~ 的效果是一样的，但是这里有一点，如果我们使用的是普通账户的话，我们的主目录就是账户主目录，如果我们比较牛批，是root账户，那么使用这个操作是会直接到达根目录下的 root/ 目录下面。<br><img src="https://img-blog.csdnimg.cn/20191116174537887.png" alt="不同用户的主目录"><br>cd的命令都很简单啦，相信你肯定可以的。</p><hr><h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><p>这部分讲一下 touch, mkdir, rm, cp, mv, cat, more, less 这几个命令，各个都是很常用的命令！</p><blockquote><p>touch(选项)(参数)</p></blockquote><p>touch命令有两个用法，第一个用法是创建一个空文件，就是啥都没有的文件，前提是这个文件如果在当前目录不存在的话。</p><p>第二个用法，就是改变一个已经存在的文件的存取时间，又拿我的Ubuntu举例子：<br><img src="https://img-blog.csdnimg.cn/2019111618075341.png" alt="touch演练"></p><blockquote><p>mkdir (选项)(参数)</p></blockquote><p>mkdir是一个创建目录的命令，默认是在当前路径下创建新的目录，这里着重介绍一个选项 <strong>-r</strong><br>这个选项能干嘛呢？先用我的Ubuntu(我的Ubuntu：你没完没了了啊！)来给大家演示一下:<br><img src="https://img-blog.csdnimg.cn/20191116181452804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="mkdir演练"><br>ok，演练结果如上，首先我在桌面利用mkdir创建了一个目录csdn，但是如果我想直接用mkdir创建多级目录的时候，它不干活了，于是我加上了一个 -r 选项，就可以了，如图我已经成功创建了三级目录 a/b/c ， 所以<strong>大家就将-r选项理解成可以帮助我们创建多级目录的选项好了</strong></p><blockquote><p>rm (选项)(参数)<br>rm命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。<br>注意：使用rm命令要<strong>格外小心</strong>。因为一旦删除了一个文件，就无法再恢复它。所以，在删除文件之前，最好再看一下文件的内容，确定是否真要删除。rm命令可以用-i选项，这个选项在使用文件扩展名字符删除多个文件时特别有用。使用这个选项，系统会要求你逐一确定是否要删除。这时，必须输入y并按Enter键，才能删除文件。如果仅按Enter键或其他字符，文件不会被删除。</p></blockquote><blockquote><p>选项<br>-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录；<br>-f：强制删除文件或目录；<br>-i：删除已有文件或目录之前先询问用户；<br>-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；<br>-v：显示指令的详细执行过程。</p></blockquote><p>这可是个大杀器啊，首先，听我一句话，千万不要获取了root权限之后跑到根目录 rm -rf *, (或者你也可以试试，如果是公司的服务器的话，先把逃生机票买好)。这个我就不用我的Ubuntu来演示了。<br>rm，由remove简化而来，是一个删除文件和目录的命令，如果想要删除目录就要加上-r 选项，代表递归删除，否则只能删除文件。话不多说，用我的Ubuntu给大家演示一下</p><p><img src="https://img-blog.csdnimg.cn/2019111618243932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="rm演练"></p><blockquote><p>cp(选项)(参数)<br>cp命令用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。</p></blockquote><p>这个选项就介绍一个吧，递归复制</p><blockquote><p>-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；</p></blockquote><p>不多说，我的Ubuntu，上：<br><img src="https://img-blog.csdnimg.cn/20191116183008789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="cp演练"></p><blockquote><p>mv(选项)(参数)</p></blockquote><p>mv, 由move简化而来，顾名思义，移动，这就是移动文件的命令</p><blockquote><p>选项<br>-b：当文件存在时，覆盖前，为其创建一个备份；<br>-f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录；<br>-i：交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。</p></blockquote><p>我的Ubuntu，开始演练：<br><img src="https://img-blog.csdnimg.cn/20191116183307356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="mv演练"><br>写多了就开始懒，我这里演练的是最基础的用法，各种选项请大家自行尝试，毕竟写的还是很清楚滴。</p><blockquote><p>cat(选项)(参数)<br>cat命令连接文件并打印到标准输出设备上，cat经常用来显示文件的内容</p></blockquote><blockquote><p>选项：<br>-n或-number：有1开始对所有输出的行数编号；<br>-b或–number-nonblank：和-n相似，只不过对于空白行不编号；</p></blockquote><p>我的Ubuntu，发功：<br><img src="https://img-blog.csdnimg.cn/20191116183814564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="cat演练"><br>这里我用了-b参数，空白行不记录行号，如果是-n的话空白行也有行号，我们平时用的比较多的是-n 喔！</p><p>more, less这两个命令都是读取文件内容并打印在终端上的。就我个人来说我更钟情于less，没别的原因，因为less比more强！</p><blockquote><p>less(选项)(参数)</p></blockquote><blockquote><p>选项<br>-e：文件内容显示完毕后，自动退出；<br>-N：每一行行首显示行号；<br>-s：将连续多个空行压缩成一行显示；<br>-S：在单行显示较长的内容，而不换行显示；</p></blockquote><p>less与more的共同点在哪呢？都是可以一屏一屏显示文档内容。啥？什么叫一屏一屏显示？我的Ubuntu，上！<br><img src="https://img-blog.csdnimg.cn/20191116184407793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="less演练"><br>来围观一下，我使用cat直接读取我写的hello.txt 文件，因为太多行了，我一显示，直接给我窜底部来了，那我还要自己滑进度条滑上去看嘛？太不人性化了，这就叫，不是一屏一屏显示。<br>现在开始我们的一屏一屏显示，我的Ubuntu（Ubuntu：明白了您嘞）:<br><img src="https://img-blog.csdnimg.cn/20191116184759752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="less演练"><br>看到第一行没有！“我是开头！”，这就是第一行，刚刚直接给我窜到底，现在我能看见第一行了，并且我只要按一下空格，它就给我翻一屏，对，<strong>翻一屏</strong>，而如果我按回车，它就给我翻到下一行！按q退出，<strong>按方向键的↑还可以向上翻</strong>——这就是和more不同的地方，more是不支持向上翻的，但是less支持！所以我选less，其他地方less和more基本相同。</p><p>好了，好累啊，让我的Ubuntu来跟大家道个别：（Ubuntu：<strong>***</strong>（口吐芬芳））<br><img src="https://img-blog.csdnimg.cn/20191116185201471.png" alt="拜拜"></p><p>谢谢你来看我！<br>我的个人博客<a href="http://hsluoyang.club">hsluoyang.club</a><br>网址是 <a href="http://hsluoyan.club" target="_blank" rel="noopener">http://hsluoyan.club</a><br>欢迎来访</p>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>让程序员爱不释手的两个网站</title>
    <url>/%E8%AE%A9%E7%A8%8B%E5%BA%8F%E5%91%98%E7%88%B1%E4%B8%8D%E9%87%8A%E6%89%8B%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%AB%99.html</url>
    <content><![CDATA[<h4 id="有一段时间没有写博客了，今天分享两个特别实用的网站给大家"><a href="#有一段时间没有写博客了，今天分享两个特别实用的网站给大家" class="headerlink" title="有一段时间没有写博客了，今天分享两个特别实用的网站给大家"></a>有一段时间没有写博客了，今天分享两个特别实用的网站给大家</h4><p>第一个网站的链接在这：<a href="https://geekdocs.cn/" target="_blank" rel="noopener">https://geekdocs.cn/</a><br>关于这个网站，我只能用一个字来形容它，牛逼！<br>你点开就会发现，这是一个非常专业的网站<br>给你们截个图看看↓↓↓</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20191112190239857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="尚未添加描述"><br>首先，它的顶部是一个搜索框，如果你有能力的话，你就可以用谷歌搜索啦哈哈。</p><p>左边是一个导航栏，可以看到有各种各样的分类，从博客，咨询，数据可视化，前端工具，等等东西应有具有，绝对是程序员的天堂！我拿几个我用过觉得好的举例子吧。</p><p>第一个是里面有的135编辑器，如果你看不到的话可以直接站内搜索找到，它是一个相对免费而且实用的微信公众号排版编辑器，有很多好看的免费素材，也可以把你的markdown生成的界面直接复制过去照样能用！</p><p>第二个就是里面的linux常用命令大全，作为程序员，会linux的使用还是很有必要的！但是我们也不能把linux命令都记住，一些忘了的和不常用的可以随时在里面查找使用方法，管用！</p><p>第三个，如果你是一个前端程序员甚至是一个美工的话，在左边的导航栏有个设计导航和神器推荐，保管你流连忘返，各种颜色搭配，漂亮图片。</p><p>除此之外，里面还有很多有意思的东西，你看下面这些，每一个网站都是一个有趣的灵魂设计的。<br><img src="https://img-blog.csdnimg.cn/20191112191914225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p>分割一下</p><hr><p>接下来说第二个网站<a href="http://code.giffox.com/" target="_blank" rel="noopener">http://code.giffox.com/</a><br>这个网站你乍一看可能没有上一个那么专业，但我想说的是，它也真的超级棒！<br><img src="https://img-blog.csdnimg.cn/20191112192237335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="棒棒的"><br>这个网站看起来专业性弱一点，但是更接地气一点，大家看图就能大致知道它有些什么功能啦，其中有一个就是我们程序员可能平时要用到但是又懒得打开的PS软件，这里面有一个网页版的PS软件，操作功能都差不多，使用起来很舒畅！反正我是喜欢上了！</p><p>如果你喜欢的话，记得在收藏网站的时候顺便给我点个赞？<br>谢谢你来看我！</p>]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>python标准数据类型复习</title>
    <url>/python%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%8D%E4%B9%A0.html</url>
    <content><![CDATA[<h4 id="好久没有学习Python了，现准备重新将Python学习提上进程，先写篇博客复习一下学过的知识点"><a href="#好久没有学习Python了，现准备重新将Python学习提上进程，先写篇博客复习一下学过的知识点" class="headerlink" title="好久没有学习Python了，现准备重新将Python学习提上进程，先写篇博客复习一下学过的知识点"></a>好久没有学习Python了，现准备重新将Python学习提上进程，先写篇博客复习一下学过的知识点</h4><p>ps：我学的Python是Python3哦</p><hr><p>我是一段分割区间<del>~</del></p><hr><h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p><em>number, string, list, tuple, set, dictionary.</em><br><strong>注意</strong>：当Python定义一个变量并赋初值的时候，这个变量就被创建出来，并且此处所说的类型不是变量的类型，<strong>变量不存在类型，就只是变量</strong>，这里所说的类型是创建的对象的类型，例如：<br>number = 100 # 此处创建了一个int类实例对象，用变量number指向它</p><p>其中的number数据类型，在Python3中包括 int, float, bool, complex(复数)<br>复数的创建方式是调用complex函数<br>例如：<br><strong>cpx = complex(5, 6)</strong><br>此处 cpx 的值为复数 (5+6j)</p><p>标准数据类型中， 存在4个容器类型，分别是 set(集合), list(列表), tuple(元组), dictionary(字典)</p><a id="more"></a><p><em>关于四种容器类型，在这里只是概述了：</em></p><blockquote><p><strong>列表：</strong></p><hr><p><strong>定义：</strong><br>使用 [ ] 或者list() 例： a = [ ] / a = list()<br><strong>增长：</strong> 使用append(要添加到末尾的元素) ，insert(插入的位置，插入的元素)， extend(要组合的新列表)<br><strong>缩减：</strong> pop(默认最后一个元素删除，也可输入索引)，remove(根据值删除)<br><strong>转置：</strong> reverse() 列表头尾反转重新排列<br><strong>排序：</strong> sort()<br><strong>查找：</strong> index(value) 返回value第一次出现的索引，count(value) 返回value出现的次数， in 关键字，返回bool值 例如: a = [10, 20]，那么 10 in a 会返回True<br><strong>计算：</strong> sum()， 计算列表中所有数据的总和， max(), min() 分别返回列表中元素最大，最小值<br><strong>合并：</strong> 加法 + 运算，合并两个列表，返回新的列表， 乘法 * 复制 n 次，生成新列表<br><strong>大小：</strong> len(), 返回列表长度<br><strong>切片：</strong> list[start : end : sted] start 和 end 切割的区间，左开右闭， sted表示每次切割的步长</p><hr><p><strong>元组：</strong></p><hr><p>元组操作与列表类似，但是，元组是不可变类型（关于不可变类型，下文会有讲）！所以列表的 增长，缩减，排序，转置函数都不能使用， 只能使用 + 和 * 合并或复制元组，切片功能也可以使用。这些能使用的功能最终都会返回一个新的元组！！原来的元组本身并没有发生变化</p><hr><p><strong>字典：</strong></p><hr><p><strong>定义：</strong> 使用 {} 或者 dict() ,例如：a = {} / a = dict()<br><strong>key 与 value ：</strong> 列表与元组通过索引index来寻找值value, 而字典利用关键字 key 来寻找相对应的value，与c++数据结构中的哈希表类似，也与现实生活中的字典类似，<em>注意：</em> 字典的key值只能是不可变类型，而value可以是任意类型，甚至本身可以是一个字典。<br><strong>例子：</strong> bands = {“Marxes”: [“Moe”, “Curly”], “KK”: [True, “moon”] }，前面一个是字符串+列表组合， 后面一个也是字符串+列表组合，但是后面的列表里面是bool类型和字符串类型的组合<br><strong>字典的增长/更新方法：</strong><br>1.直接添加，例如： student = {} ， student[“name”] = “Tom”, student[“age”] = 20, 此处若是”age”存在，则更新，若是不存在，则是添加，”name” 同理。<br>2. 在上一个例子 student 的基础上， bar = {“course”: [“数学”, “英语”]}， 创建一个新的字典，然后 student.update(bar)，则是将字典bar合并进入student， 也可以直接 student.update(friends = [“Mike”, “Alice”])。<br><strong>字典的删除方法：</strong><br>1.pop(key) 删除指定标签和它的数据，把它的value值返回出来。<br>2.popitem() 删除随机标签和它的数据，并把它以元组方式返回出来。<br>3.clear() 清空字典中的所有元素<br><strong>字典长度：</strong> len() # 所有的容器都可以使用len()来获得长度<br><strong>访问字典：</strong> keys() 返回字典中的所有关键字，即标签， values() 返回字典中的所有value值， items() 将每个数据项表示为二元元组， 返回所有的数据项<br><strong>在字典下查找：</strong> in 操作，查找字典中是否含有某个关键字， 返回值是bool类型， in 与value 配合 “Tom” in student.values() 即可查找字典中的value值。 除此之外，in 操作还可以与keys() , items() 配合。</p><hr><p><strong>集合：</strong></p><hr><p><strong>事先声明：</strong> 集合与字典类似，如果说字典是key值与value值一对一对应的，那么集合就是只存在key值，<strong>注意：</strong> 这里的key依然是不可变类型，集合是一个标签带，并且这个标签带里的标签不允许重复，会自动去重。<br><strong>创建集合：</strong> 使用{}或者set()， 并且，set()函数可以从其他序列容器转换成集合，例如，元组，列表，字符串，放到set()的()中会转换成集合。<br><strong>增长集合：</strong> 使用add()增加一个元素，或者使用update() 批量增加元素<br><strong>缩减集合：</strong><br>1.remove() / discard() 两者都是删除指定元素，不同之处在于当要删除的元素不存在时， remove()会报错而discard()不会。<br>2.pop() 这个就有点古怪，它会删除任意一个元素并且返回值，就是说，先斩后奏。<br>3.clear() 清除所有的元素<br><strong>集合大小：</strong> 依然用len() 来获取，你记好了嘛？<br><strong>访问元素：</strong> in 操作对集合同样适用喔，可以判断某个元素是否在集合内， 或者适用迭代来实现访问所有元素， for item in myset: 实现。<br><strong>集合运算：</strong> 敲黑板！这部分很厉害哦， 众所周知我们数学上的集合可以进行各种运算，比如并，交等，在python中的set同样可以哦！</p><table><thead><tr><th>运算操作</th><th>示例</th></tr></thead><tbody><tr><td>并</td><td>aset | bset</td></tr><tr><td>交</td><td>aset &amp; bset</td></tr><tr><td>差</td><td>aset - bset</td></tr><tr><td><strong>关系判定：</strong> 当然集合的关系判定也是少不了的啦，一起来看看吧。</td><td></td></tr><tr><td>关系</td><td>示例</td></tr><tr><td>—</td><td>—</td></tr><tr><td>子集</td><td>aset &lt;= bset</td></tr><tr><td>真子集</td><td>aset &lt; bset</td></tr><tr><td>超集</td><td>aset &gt;= bset</td></tr><tr><td>真超集</td><td>aset &gt; bset</td></tr><tr><td>相等</td><td>aset == bset</td></tr><tr><td><strong>什么时候用集合呢？</strong></td><td></td></tr><tr><td>1.快速去除重复项：假如一个列表中有大量的重复，我们可以把列表放到集合里去，可以高效去重</td><td></td></tr><tr><td>2.判断元素是否在一组数据中，即使用 in 操作，in操作在集合中拥有比在列表中更好的性能。</td><td></td></tr></tbody></table></blockquote><hr><p>好啦，接下来我们谈谈可变类型和不可变类型。<br>可变类型：列表，字典，集合<br>不可变类型：整型，浮点型，字符串，逻辑值，元组</p><p>根据我个人的理解，可变类型就是，数据本身变了，不可变类型就是，数据本身不会变，如果你对它进行操作，也只是在它的基础上产生一个新的值再赋值给你的变量。<br>举栗子：<br>a = “I’m handsome”<br>a = a + “I think so”<br>最终a的值会变成两个之和，但是！！！注意了，”I’m handsome”这个字符串本身并没有变，你只是把一个值和它加起来又赋值到了a身上而已<br>再来：<br>a = [1, 2, 3]<br>a.append(4)<br>这个时候，你就要注意，[1, 2, 3]这个列表本身已经变了，等于[1, 2, 3]它本身已经不存在了，变成了新的东西了。</p><p>如果你理解了，那么这里面还有一个问题你必须知道，这也是很可能会犯的一个小错误，错误很微小，但是结果很致命！</p><p>很多人喜欢把Python里的变量比作标签，是贴在某个数据上的，这种比喻主要用来针对不可变类型，很形象生动，这里有个简单的问题问大家：<br>定义 num1 = 20, num2 = num1<br>如果我们对num1进行操作， num1 += 10<br>此时， num2 的值是什么？答案是，20，几乎不用想<br>这个时候你必须要注意了！！ 我们说过 数 是不可变类型，那么对于可变类型呢？<br>我们定义 lt1 = [10, 20] lt2 = lt1<br>我们再对lt1进行操作 lt1.append(30)<br>这个时候，我再问你， lt2 的值是什么？可能我这样的态度已经让你察觉到了<br>没错，这个时候，lt2的值就不是原来的 [10, 20]了，它也随lt1变化了！<br>现在，lt2的值，同样变成了[10, 20, 30]！<br><strong>在python中，如果几个变量同时对应同一个可变类型的对象，那么任意一个变量对这个对象进行操作之后，其他所有变量的值同时进行改变！牢记这一点</strong></p><p>下次继续更新<br>谢谢你浏览！！这对我很重要<br>此外，欢迎来我的csdn博客观看 <a href="https://blog.csdn.net/luoyangIT/article/details/102779702" target="_blank" rel="noopener">落阳的csdn博客</a></p>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>埃氏筛法的更优化——欧拉筛法的详解</title>
    <url>/%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95%E7%9A%84%E6%9B%B4%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95%E7%9A%84%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h1 id="这个线性复杂度的欧拉素数筛法，爱了爱了"><a href="#这个线性复杂度的欧拉素数筛法，爱了爱了" class="headerlink" title="这个线性复杂度的欧拉素数筛法，爱了爱了"></a>这个线性复杂度的欧拉素数筛法，爱了爱了</h1><h6 id="今天讲一下关于欧拉筛法的原理和代码实现，实不相瞒，我也才刚get到这个筛法的点，乘着记忆清晰来教一遍梳理一下思路。"><a href="#今天讲一下关于欧拉筛法的原理和代码实现，实不相瞒，我也才刚get到这个筛法的点，乘着记忆清晰来教一遍梳理一下思路。" class="headerlink" title="今天讲一下关于欧拉筛法的原理和代码实现，实不相瞒，我也才刚get到这个筛法的点，乘着记忆清晰来教一遍梳理一下思路。"></a>今天讲一下关于欧拉筛法的原理和代码实现，实不相瞒，我也才刚get到这个筛法的点，乘着记忆清晰来教一遍梳理一下思路。</h6><p>我查阅资料的时候也在很多博客和公众号上看到关于欧拉筛法的解释和代码实现，然后想学习了之后用我自己的话重新描述一遍，希望我的角度能让你有所收获！</p><p>欧拉筛法与埃氏筛法一样，都是围绕【<strong>素数的倍数不是素数</strong>】这个核心原理来展开的，有关埃氏筛法请移步我的上一篇博客“<a href="http://hsluoyang.club/2019/10/22/%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">埃氏筛法的详解</a>”，但是它比埃氏筛法更高效，当数据量足够大的时候，<strong>欧拉筛法的时间是埃氏筛法时间的十分之一甚至更少</strong>。</p><p>现在我们正式展开欧拉筛法的学习。</p><a id="more"></a><p>欧拉筛法效率高的一个重要原因是，<strong>它不会重复标记一个数是不是素数的倍数</strong>，例如：6是素数2的倍数，同时也是素数3的倍数，欧拉算法能做到只标记一次6。</p><p>我们先看一下代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, cnt = <span class="number">0</span>; <span class="comment">// n是你要找的素数范围，cnt代表在这个范围内素数的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> prime[<span class="number">100001</span>];<span class="comment">// 用来保存素数，注意，是用数组的值而不是用下标保存哦！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> visited[<span class="number">100001</span>];<span class="comment">// 就是这个数组！用来记录一个数是否是某个素数的倍数，标记它</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="comment">// 输入你想查找的范围</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visited));<span class="comment">// 初始化 </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(prime, <span class="number">0</span>, <span class="keyword">sizeof</span>(prime));<span class="comment">// 初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])<span class="comment">// 如果没有被标记过</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            prime[cnt++] = i;<span class="comment">// 那么它就是素数啦~，存起来存起来，cnt记得+1 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;cnt &amp;&amp; i*prime[j]&lt;=n; j++) <span class="comment">// 这个循环是最难理解的部分，我将在下文详细解释</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            visited[i*prime[j]] = <span class="literal">true</span>;<span class="comment">// 标记素数倍数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">// 这一步跳出循环是欧拉筛法高效率的关键，也是同一个合数只被标记一次的关键</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ok，代码如上，可以直接拷贝过去试试哦！</p></blockquote><p>现在来详细分解一下那个for循环代码</p><h4 id="此处我们暂时抛开-if-i-prime-j-0-break-这句代码来讨论"><a href="#此处我们暂时抛开-if-i-prime-j-0-break-这句代码来讨论" class="headerlink" title="此处我们暂时抛开 if(i % prime[j] == 0) break; 这句代码来讨论"></a>此处我们暂时抛开 if(i % prime[j] == 0) break; 这句代码来讨论</h4><hr><p>for循环的循环变量 j 每次都从 0 开始跑，而这个 j 是从 prime[] 数组中取数据的，我们就可以这样等价，for循环每次都从已经找到的素数中从头开始取值。<br>例如 prime[] 中已经判断出了 2,3,5,7 那么for循环第一次取值2，如果没有跳出的话，第二次取值3，然后没有跳出的话就一直循环到已经找出的素数末尾。</p><p>然后</p><blockquote><p>visited[i*prime[j]] = true;</p></blockquote><p>这个代码段，是用来标记素数倍数的，例如，当 i 等于2的时候，素数数组里只存在一个素数 <strong>2</strong> ，然后进入 <strong>for</strong> 循环，<strong>for</strong> 循环会将 <strong>2</strong> 取出来与 <strong>i</strong> 相乘，得到 <strong>2</strong> 的倍数 <strong>4</strong> ，标记它，然后结束 <strong>for</strong> 循环。跑过 <strong>i = 3</strong>，执行到 <strong>i = 4</strong> 的时候，千万不要以为这个时候 <strong>for</strong> 循环不执行了！ 这个时候 <strong>for</strong> 循环依旧会尽职地把 <strong>2</strong> 取出来和 <strong>4</strong> 相乘，将 <strong>2</strong> 的倍数 <strong>8</strong> 标记！然后 不会取到第二个素数 <strong>3</strong> ，因为 <strong>4 % 2 == 0</strong> ——-</p><p>纵观之，如果我们不把</p><blockquote><p>if(i % prime[j] == 0) break;</p></blockquote><p>这段代码放在内的话， for 循环的作用就是将素数的倍数都标记上。</p><hr><h3 id="讨论关键性代码段-if-i-prime-j-0-break"><a href="#讨论关键性代码段-if-i-prime-j-0-break" class="headerlink" title="讨论关键性代码段 if(i % prime[j] == 0) break;"></a>讨论关键性代码段 if(i % prime[j] == 0) break;</h3><p>然后我们开始讨论上面那一小段代码的关键性作用：</p><p>18 是素数 3 的倍数，但是我们并不会用 3 的倍数来标记掉 18 , 因为假如我们用 3 来标记 18 ，那么 i 势必要跑到 6 这样 i * 3 才会标记掉18， 但是在这之前 i 就已经被 3 之前的一个素数 2 弄死了，退出循环了。<br>那么为什么要这么做？因为 6 既然能被 2 整除， 那么 18 迟早会被 2 标记，所以这里就不要再用 3 来重复标记 18。<br>你问我怎么知道 18 迟早会被 2 标记的？ 6 能被 2 整除，那么 3 乘 6 就可以分解为 3 乘 2 乘 3， 也就是 2 乘 9 ， 2 乘 9 就标记掉了18.</p><hr><h3 id="如果你看懂了上面的代码，我们再来总结一下"><a href="#如果你看懂了上面的代码，我们再来总结一下" class="headerlink" title="如果你看懂了上面的代码，我们再来总结一下"></a>如果你看懂了上面的代码，我们再来总结一下</h3><p>有个规律，不知道大家发现没有，<strong>凡是 i 跑到偶数位的时候，它永远只能与素数 2 相乘一次来标记掉一个数，然后因为能整除 2 而退出循环。</strong> 从这个规律，这个筛法的时间复杂度就可见一斑了。<br><strong>外层 i 循环用来选出素数和作为标记素数倍数的倍数因子，内层 j 循环用来从素数中最小的开始遍历作为标记素数倍数的素数因子。然后通过 i % 素数 == 0 来退出标记避免重复标记。</strong></p><p>谢谢你的观看！</p><p>你也可以转到我的csdn博客上去观看<a href="https://blog.csdn.net/luoyangIT/article/details/102731581" target="_blank" rel="noopener">http://hsluoyang.club/</a></p>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>埃氏筛法的理解与代码实现</title>
    <url>/%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<h1 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h1><h2 id="一个判断素数的高效算法"><a href="#一个判断素数的高效算法" class="headerlink" title="一个判断素数的高效算法"></a>一个判断素数的高效算法</h2><p>关于埃氏筛法的百度百科解释在这里<a href="https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984" target="_blank" rel="noopener">埃拉托斯特尼筛法</a>，当然我不可能给个百度百科的解释就撤，那会被打死的。<br>众所周知，素数指的是<strong>除了1和它本身之外没有其它约数的数</strong><br>我们假定一个数num，那么如果我们想通过编程来判断它是不是素数，我们首先通过它的定义想到暴力枚举方法，即用for循环配合取模操作实现，c++代码如下</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>; <span class="comment">// flag作为标志来标识这个数是不是素数，默认设置为true</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;num/<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num % i == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="literal">false</span>; <span class="comment">// 如果能被整除了，那就不是素数，退出循环</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"数："</span>&lt;&lt;num&lt;&lt;<span class="string">"是素数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这种方法就显得很麻烦，虽然直观易懂，但是时间复杂度达到了n^2级。<br>当然如果稍微改进一点的话就会知道把我上面的代码循环中的i &lt; num/2改成i*i &lt; num，时间可以缩短。但是仍不够明显。</p><hr><p>快乐的分割线</p><hr><h2 id="下面我们开始埃氏筛法的学习"><a href="#下面我们开始埃氏筛法的学习" class="headerlink" title="下面我们开始埃氏筛法的学习"></a><strong><em>下面我们开始埃氏筛法的学习</em></strong></h2><p>看过上图百度百科的同学应该明白，埃氏筛法是范围判断素数的方法，即，你给出一个数n，我用埃氏筛法能判断从1-n的所有素数出来。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><h4 id="素数的倍数肯定不是素数"><a href="#素数的倍数肯定不是素数" class="headerlink" title="素数的倍数肯定不是素数"></a><em>素数的倍数肯定不是素数</em></h4><p>给定一个数n，我们开一个大小为n+1的bool型数组，即 bool nums[n+1] ，并全部初始化为false， 在这里声明一点，这个数组的 nums[0] 与 nums[1] 我们并不会使用到。<br>建立了这样一个数组之后，我们就可以直接开干啦，我们首先要找到最小的素数，即2，从而开始循环开炮<br>OK非常棒，现在我们已经能找出素数中的最小者了，任务完成一半！<br>接下来，我们应用我们的原理——<strong>素数的倍数肯定不是素数</strong><br>这里有张表</p><table><thead><tr><th>值</th><th>是否是素数</th></tr></thead><tbody><tr><td>2</td><td>是</td></tr><tr><td>3</td><td>是</td></tr><tr><td>4</td><td>不是（通过素数2的倍数判断）</td></tr><tr><td>5</td><td>是</td></tr><tr><td>6</td><td>不是（通过素数2,3的倍数判断）</td></tr><tr><td>7</td><td>是</td></tr><tr><td>8</td><td>不是（通过素数2的倍数判断）</td></tr><tr><td>9</td><td>不是（通过素数3的倍数判断）</td></tr></tbody></table><h6 id="加入我们要求10以内的素数，开一个nums-11-，然后定位找到最小的素数-gt-2，以2为基点，开炮，把2的倍数全部打死，当然这个也是有范围的，2的倍数我们只要判断到小于n就可以了，即小于10。然后2的倍数打死完了，再找幸存的最小素数3，以3为基点，开炮，在3的炮火攻击下，上次侥幸存活的9被揪出来打死了。-我们会一直判断，直到我们的基点达到一个临界点——小于等于n的开根号，这样我们就把所有潜藏的合数敌人全部消灭了，不信你瞅瞅？"><a href="#加入我们要求10以内的素数，开一个nums-11-，然后定位找到最小的素数-gt-2，以2为基点，开炮，把2的倍数全部打死，当然这个也是有范围的，2的倍数我们只要判断到小于n就可以了，即小于10。然后2的倍数打死完了，再找幸存的最小素数3，以3为基点，开炮，在3的炮火攻击下，上次侥幸存活的9被揪出来打死了。-我们会一直判断，直到我们的基点达到一个临界点——小于等于n的开根号，这样我们就把所有潜藏的合数敌人全部消灭了，不信你瞅瞅？" class="headerlink" title="加入我们要求10以内的素数，开一个nums[11]，然后定位找到最小的素数-&gt;2，以2为基点，开炮，把2的倍数全部打死，当然这个也是有范围的，2的倍数我们只要判断到小于n就可以了，即小于10。然后2的倍数打死完了，再找幸存的最小素数3，以3为基点，开炮，在3的炮火攻击下，上次侥幸存活的9被揪出来打死了。*我们会一直判断，直到我们的基点达到一个临界点——小于等于n的开根号，这样我们就把所有潜藏的合数敌人全部消灭了，不信你瞅瞅？ *"></a>加入我们要求10以内的素数，开一个nums[11]，然后定位找到最小的素数-&gt;2，以2为基点，开炮，把2的倍数全部打死，当然这个也是有范围的，2的倍数我们只要判断到小于n就可以了，即小于10。然后2的倍数打死完了，再找幸存的最小素数3，以3为基点，开炮，在3的炮火攻击下，上次侥幸存活的9被揪出来打死了。<strong>*我们会一直判断，直到我们的基点达到一个临界点——小于等于n的开根号，这样我们就把所有潜藏的合数敌人全部消灭了，不信你瞅瞅？ *</strong></h6><p>原理如此，接下来附上这一部分的代码，看完代码之后我会有一个小小的问题遗留给大家思考</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">// 这里只给出实现代码了，上面的头文件什么的都没写了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="keyword">bool</span>* nums = <span class="keyword">new</span> <span class="keyword">bool</span>[num];   <span class="comment">// 这里我们如果需要用变量创建数组的话必须这样创建喔！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sn = <span class="built_in">sqrt</span>(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sn; i++) <span class="comment">/* 从最小的素数2开始开炮*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; num; j+=i)  <span class="comment">// 此处需要注意，我们开炮的时候，第一颗炮弹直接打到i的平方上，这是避免了重复判断，j每次要增长i</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums[j] = <span class="literal">false</span>;   <span class="comment">// 跟我一起，开炮！！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"\t"</span>;  <span class="comment">// 打印出选出来的素数你看看，这里我喜欢用制表符，个人习惯，看着舒服</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> []nums;  <span class="comment">// 最后可别忘了释放指针内存哦，并且将指针置空，养成好习惯，不要野指针！</span></span><br><span class="line">    nums = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，代码部分结束，最后我还遗留一个问题，你们有没有发现，我们这里重复判断了？比如我已经判断12是偶数了，已经杀死了，但是我以3为基点开炮的时候，还是会再打它一次，炸尸，这会不会浪费我们的炮弹资源（时间）呢？该如何改进这个问题呢？思考一下？</p><h3 id="谢谢你来看我！"><a href="#谢谢你来看我！" class="headerlink" title="谢谢你来看我！"></a>谢谢你来看我！</h3>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>起航-个人博客的开始</title>
    <url>/%E8%B5%B7%E8%88%AA-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BC%80%E5%A7%8B.html</url>
    <content><![CDATA[<hr><h2 id="感言"><a href="#感言" class="headerlink" title="感言"></a><div align="center">感言</div></h2><p>搭建一个自己的博客真的是太太太太不容易了！但是也太太太太有成就感了！</p><p>我原先是在<strong>CSDN</strong>上写博客，特别羡慕他们那些自己搭建博客的<br>整个网站都是自己的，想怎么设计怎么设计<br>特别是当我看见一些做的很好的个人博客的时候，就总是想着自己要是有个那该多好<br>于是我这在csdn屁股都没坐热呢，就又屁颠屁颠跑来在网上搜罗搭建个人博客的方法</p><a id="more"></a><p>鉴于技术栈的短小，我最后采用了一个比较简单的框架来搭建我的网站<br>主题采用的是<strong>yilia</strong>（右下方可见），作者是腾讯的一位前端前辈<strong>Litten</strong><br>主题很简洁漂亮，而且反应速度也很快，虽然在手机上好像不能很好兼容<br>没关系！我会改的，前辈的东西虽好，但后来人也要有自己的想法啊！</p><blockquote><p><strong>在此立个flag啊，以后我肯定会利用自己的技术来完善自己的博客网站</strong></p></blockquote><p>还有markdown语法，目前我还用的不太熟练，写出来的文章水平也不够，我也会慢慢学的！<br><img src="./起航-个人博客的开始/xiangxin.jpg"></p><p>emmm，一时想不起来要说些什么了，那就为自己加一下油<br>对于博客，我可是寄予了厚望啊，我的费曼学习法，我的技术成长日记<br>我的技术试验平台甚至是代码小仓库<br>所以我会严格要求自己写博客的！！</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a><div align="center">目标</div></h2><p>目标我有过很多，但是大多都会夭折在半路<br><img src="./起航-个人博客的开始/gouzi.jpg"><br>我大致总结了一下啊，夭折的原因无非就是这几点</p><blockquote><ul><li>决心不够</li><li>知道会很难，没有勇气开始</li><li>开始后发现自己并不喜欢或者并没有天赋</li><li>在无知的时候立下目标，在向目标迈进时渐渐认识到困难，然后放弃</li></ul></blockquote><p>分别说一下吧</p><table><thead><tr><th>原因</th><th align="center">我</th></tr></thead><tbody><tr><td>决心不够</td><td align="center">我想把我的英语水平再提上去，特别是口语，我也知道要怎么做，但是<em>因为决心不够，进展几乎没有</em></td></tr><tr><td>太难了</td><td align="center">我想联系自己的沟通能力，特别是<em>在很多人面前表达自己<em>，还有学会说话，</em>做一个相处起来很舒服的人</em></td></tr><tr><td>兴趣原因</td><td align="center">我也买来吉他，想练到能弹一些简单的曲目的程度，但是后来我发现我好想对它不是很感兴趣，也搁下了</td></tr><tr><td>无知</td><td align="center">我曾想只要我够努力，我就可以在大学里靠着自己的编程技术赚钱，刚开始想靠c++，发现一个人做项目很难，转而向前端，又发现现在前端的水也不浅，各种框架，只会写静态页面根本没什么用，再转向Python，但是Python门槛低，简单的人家都给你做好了，大众技术就是在出卖劳动力而已</td></tr></tbody></table><p>当然这些目标的存在并不是毫无意义<br>是它们一步一步构成现在充满动力的我，也让我的视野开阔起来，所学的东西也不局限于学校教的了<br>其实关于第四个原因我写的时候是有点纠结的，因为这可能不能构成一个原因，纯属我的努力没有达到那个程度</p><p>而我现在的目标呢就是保持之前的努力程度，戒掉浮躁，任何知识都是沉淀而来的，把所学的都学好，再学一些新的<br>每天给自己一些任务，然后完成任务，一步步来</p><p>最后简要介绍一下我目前的知识</p><blockquote><p>c,c++基本语法加上stl基本知识，用c++写一些算法和数据结构 , Qt可视化编程也会一些<br>java基本语法（不熟练）<br>html5, css3 的基本使用<br>linux系统日常使用（维护暂时还做不到）<br>python 基本语法加上一些简单的库的基本使用，Python的多线程多进程多协程</p><blockquote><p>正则表达式，海龟作个图，pygame写个飞机大战，调用一些网站的api来抠个图保存….这方面比较杂</p></blockquote></blockquote><blockquote><p>另外，一些其他的知识也大致知道一些，比如网络安全，数据库啊什么的，我这个人好奇心很重</p></blockquote><hr><h4 id="我挺喜欢现在的正在努力着的自己的，也感谢屏幕前的你能看完我的第一篇博客，这对我很重要"><a href="#我挺喜欢现在的正在努力着的自己的，也感谢屏幕前的你能看完我的第一篇博客，这对我很重要" class="headerlink" title="我挺喜欢现在的正在努力着的自己的，也感谢屏幕前的你能看完我的第一篇博客，这对我很重要  "></a><div align="center"><strong><em>我挺喜欢现在的正在努力着的自己的，也感谢屏幕前的你能看完我的第一篇博客，这对我很重要</em></strong></div></h4><div align="center"><img src="./起航-个人博客的开始/bixin.jpg"></div><h3 id="知学无涯，渐且行远"><a href="#知学无涯，渐且行远" class="headerlink" title="知学无涯，渐且行远"></a><div align="center"><em>知学无涯，渐且行远</em></div></h3>]]></content>
      <tags>
        <tag>想法</tag>
      </tags>
  </entry>
</search>
