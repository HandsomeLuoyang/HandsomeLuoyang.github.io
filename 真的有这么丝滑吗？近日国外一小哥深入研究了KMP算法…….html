<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="keywords" content="c++, python, java, html5, css3, 编程, 学生编程，个人博客，大学生博客"><meta name="description" content="目前是大二学生，没有可以拿出来说道的东西，慢慢学，慢慢走"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>真的有这么丝滑吗？近日国外一小哥深入研究了KMP算法…… | 落阳的博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css"><script src="/js/pace.min.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?e8170de70defad40967f38f95ed385aa";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><meta name="generator" content="Hexo 4.2.0"></head></html><body><div id="app"><main class="content"><section class="outer"><article id="post-真的有这么丝滑吗？近日国外一小哥深入研究了KMP算法……" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal><div class="article-inner"><header class="article-header"><h1 class="article-title sea-center" style="border-left:0" itemprop="name">真的有这么丝滑吗？近日国外一小哥深入研究了KMP算法……</h1></header><div class="article-meta"><a href="/%E7%9C%9F%E7%9A%84%E6%9C%89%E8%BF%99%E4%B9%88%E4%B8%9D%E6%BB%91%E5%90%97%EF%BC%9F%E8%BF%91%E6%97%A5%E5%9B%BD%E5%A4%96%E4%B8%80%E5%B0%8F%E5%93%A5%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E4%BA%86KMP%E7%AE%97%E6%B3%95%E2%80%A6%E2%80%A6.html" class="article-date"><time datetime="2020-05-11T03:00:48.000Z" itemprop="datePublished">2020-05-11</time></a></div><div class="article-entry" itemprop="articleBody"><p>近日被朋友问到了字符串匹配算法，让我想起了大二上学期在一次校级编程竞赛中我碰到同样的问题时，为自己写出了暴力匹配算法而沾沾自喜的经历。</p><p>现在想来，着实有点羞愧，于是埋头去学习了一下KMP算法，为了让自己不至于那么快忘记，也希望小伙伴们能从我的理解中收获一点自己的感悟！</p><p>文章伴有精心雕琢的动画以便理解。</p><a id="more"></a><p><strong>我们首先来分析一下暴力算法，为鲜花的诞生献上绿叶！</strong></p><p>以下文中统一将需要被匹配的字符串（长的那段）称为<strong>待匹配串</strong> ，把用来匹配的字符串（短的那段）称为<strong>模式串</strong>。</p><p>暴力匹配算法的思路很简单，就是每一次都首先将待匹配串和模式串的首字母对齐，然后比对是否相同，若相同则继续比对两个串的下一个位置，如果不相同的话就将模式串向右移动一位，然后再重新开始从头匹配，就像下面这样⬇️⬇️<br><img src="https://img-blog.csdnimg.cn/20200510212619433.gif#pic_center" alt="暴力搜索演示"><br>从上面的动画我们可以直观的看出来，下面的模式串在匹配失败之后都只会移动一格，傻里傻气的，这就导致它的时间复杂度是$M*N$，其中M是模式串的长度，N是待匹配串的长度。</p><p>对于这个时间复杂度，我不满意！它太傻了，不符合我聪明睿智的气质！</p><p>那就来分析一下为何它这么傻。我们可以看到，在第一次匹配失败的时候，我们肯定希望它向右移动至少两格，因为<strong>模式串的第一格和第三格都为a，既然第三格已经匹配成功了，那么把第一格对上第三格匹配的位置，那么无疑肯定也是可以成功的</strong>，我们的算法本该知道并且利用这一点的！但是它没有，它太傻了。</p><p>嗯，这么一说，好像是感觉应该是要把它向着动态规划的方向改（即利用已有信息为下一步提供便利）。</p><p><strong>PS：字符串问题百分之八十以上都可以使用动态规划思想达到较低的时间复杂度。</strong></p><p>我们大都听过一句老话：人啊，贵在有自知之明。</p><p>同时我们肯定也听别人说过：人只有深刻的认识了自己，才能找对位置，迅速地向目标前进！</p><p>这两句话用在KMP算法中再合适不过了！</p><p><strong>KMP算法的核心便在于，模式串对自己的自我认知！</strong></p><p>想一想，我们人对自己的认知是如何的：男，19岁，阳光帅气聪明机智，这些自我认知都存放在我的脑袋里面。</p><p>那么，模式串对自己的认知应该存放在哪呢？</p><p>对，就是next数组里面！字符串没有大脑，所以它需要额外的空间来存储它对自己的认知并籍此作出高效准确的判断。</p><p>那么字符串对自己的认知是怎样的呢？其实很容易理解，就是知道自己身上哪些地方是相同的，这样的话在匹配失败之后就能迅速找准下次开始的点。这里是不是有点模糊了？图来！<br><img src="https://img-blog.csdnimg.cn/20200511075939299.gif#pic_center" alt="KMP算法拟人化演示"><br>以上就是KMP算法的动画，如果觉得动画稍微有点快的话可以多观看几次，在这个动画里我还没有放出next数组的部分，只是用拟人化的手法展现出来。希望大家能够理解，为什么第一次匹配失败可以直接移动两格。</p><p>是因为模式串中第三格的a，它知道在第一格有与自己相同的字符，并且把这个信息告诉下一格的字符，让它在匹配失败之后直接把第一格的a移动到它的那个位置上去。</p><p>我这里为了大家容易理解，只放出了一个字符相同的情况，大家不妨可以扩展想一下，假如，第一格和第三格的a不是一个字符，而是一个字符串呢？怎么？有点打脑壳？图来！<br><img src="https://img-blog.csdnimg.cn/20200511075107181.gif#pic_center" alt="KMP算法动画"></p><p>来看看模式串与其对应的next自我认识数组吧。<br>| i|0|1|2|3|4|5|6|<br>|–|–|–|–|–|–|–|–|<br>|next|-1|0|0|0|1|2|3|<br>|string|a|b|c|a|b|c|d|</p><p>不要去在意next数组的第一个为什么是-1，这是为了代码写的方便，暂且就给它当成0.</p><p>在动画中，当一个字符发出“直接移动”的语句的时候，其实是告诉后一个字符，如果你匹配失败了的话，就直接移动，同时后一个字符对应的next数组值为0，当后一个字符匹配失败了，就移动<code>模式串的长度-这个匹配失败的字符对应的next值</code>个长度。</p><p>从第四个字符（i=3）起，它们都在不断告诉后面一个字符：“将i=0移动到i=3的位置”，这句话对于i=4的字符来说，是移动<code>4-1</code>格， 对于i=5的字符来说，是移动<code>5-2</code>格，对于i=6的字符来说，是移动<code>6-3格</code>：后面那个减数恰好就是这个字符对应的next数组的值!</p><p>因为模式串足够了解自己，所以它能够在匹配失败的时候不用回退，不用每次只移动一格，而是跟随着待匹配串一起移动。待匹配字符串的指针从未回退过，以线性的速度向前一步步越进。</p><p>最终：KMP算法的时间复杂度是$M+N$</p><p>这里我们不禁发出了感叹！原来认识自己真的这么重要啊！</p><p><strong>接下来是求出给定模式串的next数组：</strong></p><p>python3代码奉上⬇️⬇️</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def get_next_lst(ss: str) -&gt; list:</span><br><span class="line">    length &#x3D; len(ss)</span><br><span class="line">    next_lst &#x3D; [0 for _ in range(length)]</span><br><span class="line">    next_lst[0] &#x3D; -1</span><br><span class="line">    i &#x3D; 0</span><br><span class="line">    j &#x3D; -1</span><br><span class="line">    while i &lt; length - 1:</span><br><span class="line">        if j &#x3D;&#x3D; -1 or ss[i] &#x3D;&#x3D; ss[j]:</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">            j +&#x3D; 1</span><br><span class="line">            next_lst[i] &#x3D; j</span><br><span class="line">        else:</span><br><span class="line">            j &#x3D; next_lst[j]</span><br><span class="line">    return next_lst</span><br></pre></td></tr></table></figure><p>这段代码最难理解的就是<code>j=next_lst[j]</code>这句话，其实这句话也是动态规划的一个思想，看我为你剖析一下。<br><img src="https://img-blog.csdnimg.cn/20200511083409329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>已知蓝色区域相等且长度都为len，那么很明显，<code>next[i] == len</code>，若此时模式串<code>pattern[i] != pattern[j]</code>（两个灰色区域不相等）。那么看下图：</p><p><img src="https://img-blog.csdnimg.cn/20200511084823550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b3lhbmdJVA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>若此时<code>next[j] == len(粉色部分)</code>那么<code>S1==S2</code>，又因为<code>next[i] == next[j]</code>，所以<code>S1==S3 且 S3 == S4</code>，则可以推出<code>S1 == S4</code>，这样我们就利用前面所获得的信息，推出了<code>S1 == S4</code>这个信息，然后将J移动到S1后一格，只要再次比较<code>patter[i] 与 patter[j]</code>的相等情况，就可以得出<code>next[i+1]</code>的值。这里因为i始终向后移动，所以也是线性时间复杂度的算法。</p><p>ohhhhhhhhh～</p><p>到这里，大家就明白了为啥KMP算法的时间复杂度是$M+N$了。</p><p>KMP匹配字符串的完整代码附上！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class KMP():</span><br><span class="line">    def __init__(self, ss: str) -&gt; list:</span><br><span class="line">        self.length &#x3D; len(ss)</span><br><span class="line">        self.next_lst &#x3D; [0 for _ in range(self.length)]</span><br><span class="line">        self.next_lst[0] &#x3D; -1</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        j &#x3D; -1</span><br><span class="line">        while i &lt; self.length - 1:</span><br><span class="line">            if j &#x3D;&#x3D; -1 or ss[i] &#x3D;&#x3D; ss[j]:</span><br><span class="line">                i +&#x3D; 1</span><br><span class="line">                j +&#x3D; 1</span><br><span class="line">                self.next_lst[i] &#x3D; j</span><br><span class="line">            else:</span><br><span class="line">                j &#x3D; self.next_lst[j]</span><br><span class="line">        self.pattern &#x3D; ss</span><br><span class="line">    </span><br><span class="line">    def match_str(self, ss:str):</span><br><span class="line">        ans_lst &#x3D; []</span><br><span class="line">        j &#x3D; 0</span><br><span class="line">        for i in range(len(ss)):</span><br><span class="line">            if ss[i] !&#x3D; self.pattern[j]:</span><br><span class="line">                j &#x3D; self.next_lst[j] if self.next_lst[j] !&#x3D; -1 else 0</span><br><span class="line">            if ss[i] &#x3D;&#x3D; self.pattern[j]:</span><br><span class="line">                j +&#x3D; 1</span><br><span class="line">            if j &#x3D;&#x3D; self.length:</span><br><span class="line">                return i + 1 - self.length</span><br><span class="line">        return -1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tmp_kmp &#x3D; KMP(&#39;iabc&#39;)</span><br><span class="line">print(tmp_kmp.match_str(&#39;adosjfoiajsoifjasiofjoiasdjoiabc&#39;))</span><br></pre></td></tr></table></figure><p><strong>看到这里，如果你觉得这篇文章对你理解KMP算法有帮助的话呢，不妨关注我，我会持续更新各种有用的东西。我的个人公众号是【程序小员】，也欢迎你的关注哦！</strong></p><p><strong>我是落阳，谢谢你的到访～</strong></p><div id="reward-btn">打赏</div></div><footer class="article-footer"><a data-url="http://hsluoyang.club/%E7%9C%9F%E7%9A%84%E6%9C%89%E8%BF%99%E4%B9%88%E4%B8%9D%E6%BB%91%E5%90%97%EF%BC%9F%E8%BF%91%E6%97%A5%E5%9B%BD%E5%A4%96%E4%B8%80%E5%B0%8F%E5%93%A5%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E4%BA%86KMP%E7%AE%97%E6%B3%95%E2%80%A6%E2%80%A6.html" data-id="cka37p35g0000m8vo80sr1ofi" class="article-share-link">分享</a><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul></footer></div><nav class="article-nav"><a href="/%E8%BD%BB%E6%9D%BE%EF%BC%8C%E9%AB%98%E6%95%88%EF%BC%8C%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB%EF%BC%9F%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81%E8%B8%A9%E8%BF%87%E6%97%A0%E6%95%B0%E5%9D%91%E5%90%8E%E6%80%BB%E7%BB%93%E7%9A%84%E7%88%AC%E8%99%AB%E7%BC%96%E5%86%99%E6%B5%81%E7%A8%8B.html" class="article-nav-link"><strong class="article-nav-caption">下一篇</strong><div class="article-nav-title">轻松，高效，正确的写出一个爬虫？看这一篇就够了！</div></a></nav><div id="vcomments-box"><div id="vcomments"></div></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
        el: '#vcomments',
        notify: false,
        verify: false,
        app_id: '5WSaK6bUDnRLhgbQjaL5R9Tq-gzGzoHsz',
        app_key: '7x0vYeAw0aRYU5SjaFugWDxh',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }</script><style>#vcomments-box{padding:5px 30px}@media screen and (max-width:800px){#vcomments-box{padding:5px 0}}#vcomments-box #vcomments{background-color:#fff}.v .vlist .vcard .vh{padding-right:20px}.v .vlist .vcard{padding-left:10px}</style></article></section><footer class="footer"><div class="outer"><ul class="list-inline"><li>&copy; 2019-2020 落阳</li><li><a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a> by shenyu</li></ul><ul class="list-inline"><li><ul class="list-inline"><li>PV:<span id="busuanzi_value_page_pv"></span></li><li>UV:<span id="busuanzi_value_site_uv"></span></li></ul></li><li></li></ul></div></footer><div class="to_top"><div class="totop" id="totop"><i class="ri-arrow-up-line"></i></div></div></main><aside class="sidebar"><button class="navbar-toggle"></button><nav class="navbar"><div class="logo"><a href="/"><img src="/images/touxiang.png" alt="落阳的博客"></a></div><ul class="nav nav-main"><li class="nav-item"><a class="nav-item-link" href="/">主页</a></li><li class="nav-item"><a class="nav-item-link" href="/archives">目录</a></li><li class="nav-item"><a class="nav-item-link" href="/tags">标签</a></li></ul></nav><nav class="navbar navbar-bottom"><ul class="nav"><li class="nav-item"><a class="nav-item-link nav-item-search" title="搜索"><i class="ri-search-line"></i> </a><a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed"><i class="ri-rss-line"></i></a></li></ul></nav><div class="search-form-wrap"><div class="local-search local-search-plugin"><input type="search" id="local-search-input" class="local-search-input" placeholder="Search..."><div id="local-search-result" class="local-search-result"></div></div></div></aside><div id="mask"></div><div id="reward"><span class="close"><i class="ri-close-line"></i></span><p class="reward-p"><i class="ri-cup-line"></i>谢谢你请我吃糖果~</p><div class="reward-box"><div class="reward-item"><img class="reward-img" src="/images/alipay.png"> <span class="reward-type">支付宝</span></div><div class="reward-item"><img class="reward-img" src="/images/weixin.png"> <span class="reward-type">微信</span></div></div></div><script src="/js/jquery-2.0.3.min.js"></script><script src="/js/jquery.justifiedGallery.min.js"></script><script src="/js/lazyload.min.js"></script><script src="/js/busuanzi-2.3.pure.min.js"></script><script src="/fancybox/jquery.fancybox.min.js"></script><script src="/js/tocbot.min.js"></script><script>tocbot.init({tocSelector:".tocbot",contentSelector:".article-entry",headingSelector:"h1, h2, h3, h4, h5, h6",hasInnerContainers:!0,scrollSmooth:!0,positionFixedSelector:".tocbot",positionFixedClass:"is-position-fixed",fixedSidebarOffset:"auto"})</script><script>var ayerConfig={mathjax:!1}</script><script src="/js/ayer.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"><script type="text/javascript" src="https://js.users.51.la/20544303.js"></script></div></body>